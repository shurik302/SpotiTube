Міністерство освіти і науки України  
Національний університет  «Запорізька політехніка»  
 
 
 
 
 
 
 
 
 
 
 
 
МЕТОДИЧНІ ВКАЗІВКИ  
до виконання лабораторних робіт  
з дисципліни  
“Технологія створення програмних продуктів ” 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
2023 
2 
 
Методичні вказівки до виконання лабораторних робіт з дисци п-
ліни “ Технологія створення програмних продуктів ” / Укл.: 
А. О. Олійник , Т. О. Колпакова, В.  М. Льовкін , С. Д. Леощенко . – За-
поріжжя  : НУ «Запорізька політехніка» , 2023. – 99 с. 
 
 
 
 
Укладачі :  А. О. Олійник , д.т.н., професор  
  Т. О. Колпакова , к.т.н., доцент  
  В. М. Льовкін , к.т.н., доцент  
 С. Д. Леощенко, доктор філософії, ст. викладач  
 
 
 
Рецензент:  С. О. Субботін , д.т.н., професор  
 
 
 
Відповідальний  
за випуск:  С. О. Субботін, д.т.н., професор  
 
 
 
 
 
 Затверджено  
на засіданні кафедри  
програмн их засобів  
 
Протокол №  1   
від “ 17” серпня  2023 р. 
 
  
3 
 
ЗМІСТ  
 
Вступ  ................................ ................................ ................................ ...........  6 
1 Лабораторна робота № 1  Збирання та аналіз вимог до 
програмного продукту  ................................ ................................ .............  7 
1.1 Мета роботи  ................................ ................................ ..........................  7 
1.2 Короткі теоретичні відомості  ................................ ..............................  7 
1.2.1 Моделі життєвого циклу  ................................ ................................ ... 9 
1.2.1.1 Гнучка розробка програмного забезпечення  .............................  13 
1.2.2 Аналіз вимог ................................ ................................ .....................  14 
1.2.3 Етапи аналізу вимог  ................................ ................................ ........  15 
1.2.4 Класифікація вимог  ................................ ................................ .........  15 
1.2.5 Користувацькі історії  ................................ ................................ ...... 16 
1.2.6 Документування вимог  ................................ ................................ ... 17 
1.3 Завдання на лабораторну  роботу ................................ .......................  20 
1.4 Зміст звіту  ................................ ................................ ............................  20 
1.5 Контрольні запитання  ................................ ................................ ........  21 
2 Лабораторна робота № 2  Проєктування програмного 
забезпечення з використанням UML  ................................ ..................  22 
2.1 Мета роботи  ................................ ................................ ........................  22 
2.2 Короткі теоретичні відомості  ................................ ............................  22 
2.2.1 Діаграма класів  ................................ ................................ ................  22 
2.2.2 Діаграма компонентів  ................................ ................................ ..... 24 
2.2.3 Діаграма прецедентів  ................................ ................................ ...... 25 
2.2.3.1 Потоки подій  ................................ ................................ .................  27 
2.2.4 Діаграма станів  ................................ ................................ ................  28 
2.2.5 Діаграма діяльності  ................................ ................................ .........  28 
2.2.6 Діаграма кооперації  ................................ ................................ .........  30 
2.2.7 Діаграма послідовност і ................................ ................................ ... 31 
2.3 Завдання на лабораторну роботу ................................ .......................  33 
2.4 Зміст звіту  ................................ ................................ ............................  33 
2.5 Контрольні запитання  ................................ ................................ ........  34 
3 Лабораторна робота № 3  Проєктування інтерфейсу 
вебзастосунків  ................................ ................................ .........................  36 
3.1 Мета роботи  ................................ ................................ ........................  36 
3.2 Короткі теоретичні відомості  ................................ ............................  36 
4 
 
3.2.1 Модель GOMS  ................................ ................................ .................  37 
3.2.2 Закон Фіттса  ................................ ................................ .....................  38 
3.2.3 Закон Хіка  ................................ ................................ .........................  39 
3.2.4 Етапи проєктування та інструменти розроблення дизайну 
інтерфейсу користувача  ................................ ................................ ...........  39 
3.3 Завдання на лабораторну роботу ................................ .......................  43 
3.4 Зміст звіту  ................................ ................................ ............................  44 
3.5 Контрольні запитання  ................................ ................................ ........  44 
4 Лабораторна робота № 4  Аналіз та проєктування 
архітектури вебзастосунків на основі предметної області  ..............  45 
4.1 Мета роботи  ................................ ................................ ........................  45 
4.2 Короткі теоретичні відомості  ................................ ............................  45 
4.2.1 Схема проєктува ння MVC – Model -View -Controller  ....................  45 
4.2.2 Архітектура MVP – Model -View -Presenter  ................................ .... 46 
4.2.3 Архітектура MVVM – Model -View -ViewModel  ............................  48 
4.2.4 Фреймворки  ................................ ................................ ......................  49 
4.2.4.1 Фреймворк Laravel  ................................ ................................ ........  50 
4.2.4.2 Фреймворк Yii2  ................................ ................................ .............  53 
4.2.5 Системи управління вмістом  ................................ ..........................  56 
4.3 Завдання на лабораторну роботу ................................ .......................  58 
4.4 Зміст звіту  ................................ ................................ ............................  58 
4.5 Контрольні запитання  ................................ ................................ ........  59 
5 Лабораторна робота №5 Програмна реалізація розробленої 
архітектури вебзастосунку  ................................ ................................ .... 60 
5.1 Мета роботи  ................................ ................................ ........................  60 
5.2 Короткі теоретичні відомості  ................................ ............................  60 
5.2.1 Менеджер пакетів Composer  ................................ ...........................  60 
5.2.2 Середовища розробки  ................................ ................................ ..... 61 
5.3 Завдання на лабораторну роботу ................................ .......................  63 
5.4 Зміст звіту  ................................ ................................ ............................  64 
5.5 Контрольні запитання  ................................ ................................ ........  64 
6 Лабораторна робота № 6 Робота із системами керування 
версіями. Розгортання репозиторію  ................................ ....................  65 
6.1 Мета роботи  ................................ ................................ ........................  65 
6.2 Короткі теоретичні відомості  ................................ ............................  65 
6.2.1 Онлайн -репозито рії ................................ ................................ .........  67 
5 
 
6.3 Завдання на лабораторну роботу ................................ .......................  70 
6.4 Зміст звіту  ................................ ................................ ............................  70 
6.5 Контрольні запитання  ................................ ................................ ........  71 
7 Лабораторна робота №7 Розширення функціональності 
вебзастосунків  ................................ ................................ .........................  72 
7.1 Мета роботи  ................................ ................................ ........................  72 
7.2 Короткі теоретичні відомості  ................................ ............................  72 
7.2.1 Приклади розширення функціональності Yii  ...............................  72 
7.2.2 П риклади розширення функціональності Laravel  ........................  74 
7.2.3 Приклади розширення функціональності CMS  ............................  75 
7.3 Завдання на лабораторну роботу ................................ .......................  77 
7.4 Зміст звіту  ................................ ................................ ............................  77 
7.5 Контрольні запитання  ................................ ................................ ........  78 
8 Лабораторна робота № 8  Тестування та аналіз якості 
вебзастосунків  ................................ ................................ .........................  79 
8.1 Мета роботи  ................................ ................................ ........................  79 
8.2 Короткі теоретичні відомості  ................................ ............................  79 
8.3 Завдання на лабор аторну роботу ................................ .......................  86 
8.4 Зміст звіту  ................................ ................................ ............................  86 
8.5 Контрольні запитання  ................................ ................................ ........  87 
Література  ................................ ................................ ................................  88 
Додаток А Приклади тем  ................................ ................................ ...... 90 
Додаток Б Приклад карти історій  ................................ .......................  95 
Додаток В Приклад опису потоку подій  ................................ .............  96 
Додаток Д Приклад складання чек -листу  ................................ .........  99 
6 
 
ВСТУП  
 
Дане видання призначене для вивчення та практичного освоєння 
студентами усіх форм навчання основ технології створення програ м-
них продуктів .  
Відповідно до графіка студенти перед ви конанням лабораторної 
роботи повинні ознайомитися з конспектом лекцій та рекомендованою 
літературою.   
Для одержання заліку з кожної роботи студент здає викладачу 
оформлений звіт, а також демонструє на екрані комп’ютера результ а-
ти виконання лабораторної роб оти. 
Звіт має містити:  
– титульний аркуш;  
– тему та мету роботи;  
– завдання до роботи;  
– лаконічний опис теоретичних відомостей;  
– результати виконання лабораторної роботи;  
– змістовний аналіз отриманих результатів та висновки.  
Звіт виконують на білому пап ері формату A4 (210   297 мм)  або 
подають в електронному вигляді .  
Під час співбесіди при захисті лабораторної роботи студент п о-
винний виявити знання про зміст роботи  та методи виконання кожн о-
го етапу роботи, а також вміти  продемонстр увати  результат и роботи  
на конкретних прикладах. Студент повинний вміти правильно анал і-
зувати отримані результати. Для самоперевірки при підготовці до в и-
конання і захисту роботи студент повинен відповісти на контрольні 
запитання, наведені наприкінці опису відповідної робот и.  
7 
 
1 ЛАБОРАТОРНА РОБОТА №  1  
ЗБИРАННЯ ТА АНАЛІЗ В ИМОГ  ДО 
ПРОГРАМНОГО ПРОДУКТУ  
 
1.1 Мета роботи  
 
Навчитися виконувати збирання, аналіз та документування в и-
мог до програмного забезпечення.  
 
1.2 Короткі теоретичні відомості  
 
Одним з ключових понять проєкт ування інформаційних систем 
є життєвий цикл (ЖЦ) проєкт у. В загальному випадку, життєвий цикл 
визначається моделлю й описується у формі методології (методу). 
Модель або парадигма життєвого циклу визначає загальну організ а-
цію ЖЦ і, як правило, основні його фази та принципи переходу між 
ними. Методологія (метод) визначає комплекс робіт, їх детальний 
зміст і рольову відповідальність спеціалістів на всіх етапах вибраної 
моделі ЖЦ; рекомендує практики, які дозволяють максимально ефе к-
тивно використовувати відпові дну методологію та її модель.  
Життєвий цикл програмного забезпечення – період часу, що п о-
чинається з моменту прийняття рішення про необхідність створення 
програмного продукту і закінчується в момент його повного вилуче н-
ня з експлуатації. Цей цикл – процес побудови і розвитку програмного 
забезпечення (ПЗ) . 
Загалом можна виділити 4 основних етапи (стадії) в процесі 
створення ПЗ, які представлені на рис. 1.1.  
Ініціація – відбувається висунення ідеї, а також підготовка проє-
ктних документів. Проводяться детальне  обґрунтування, а також ма р-
кетингові дослідження, які стануть підставою для реалізації наступних 
стадій.  
Планування – визначення термінів реалізації задуму, поділ д а-
них процесів на конкретні етапи, а також призначення виконавців та 
відповідальних осіб.  
Виконання – починається відразу ж після того, як були затве р-
джені плани. Мається на увазі реалізація в повному обсязі всіх нам і-
чених дій.  
8 
 
Завершення – аналіз отриманих даних і контроль на предмет в і-
дповідності їх запланованим. Даний обов'язок в більшості випа дків 
покладається на керівництво.  
 
 
Рисунок1.1 – Основні етапи створення ПЗ  
  
Використання певної моделі ЖЦ дозволяє визначитися з осно в-
ними моментами процесу замовлення, розроблення та супроводу ПЗ 
навіть недосвідченому програмісту. Також використання мо делей д о-
зволяє чітко зрозуміти, в який період переходити від версії до версії, 
які дії з удосконалення виконувати, на якому етапі. Знання про зак о-
номірності розвитку програмного продукту, які відбиваються в обр а-
ній моделі ЖЦ, дозволяють отримати надійні ор ієнтири для планува н-
ня процесу розроблення та супроводу ПЗ, економно витрачати ресу р-
си та підвищувати якість управління усіма процесами.  
Також моделі життєвого циклу є основою знань технологій пр о-
грамування та інструментарію, що їх підтримує. Будь -яка техн ологія 
базується на певних уявленнях про життєвий цикл та організує свої 
методи та інструменти навколо фаз та етапів ЖЦ.  
До цього часу моделі ЖЦ розвиваються і модифікуються, уто ч-
нюючи та доповнюючи дві базові моделі – каскадну та ітеративну. Ці 
зміни обум овлені потребою організаційної та технологічної підтримки 
проєкт ів з розроблення ПЗ.  Ініціація  
Планування  
Виконання 
(Розробка)  
Завершення 
(Введення в 
дію)  Використання  Супровід  
9 
 
1.2.1 Моделі життєвого циклу  
 
Модель життєвого циклу – це структура, що складається із пр о-
цесів, робіт та задач, які включають в себе розробку, експлуатацію і 
супровід програмного продукту . Вона охоплює життя системи від в и-
значення вимог до неї до припинення її використання. На сьогодні 
найбільшого розповсюдження набули наступні моделі:  
– каскадна;  
– інкрементна;  
– спіральна.  
Каскадна модель  (одноразовий прохід, водоспадна або класи ч-
на стратегія ) припускає  лінійну послідовність виконання стадій ств о-
ренн я інформаційної системи (рис. 1.2 ). Іншими словами, перехід з 
однієї стадії на наступну відбувається тільки після того, як буде по в-
ністю завер шена робота на поточній.  
 
 
Рисунок 1.2 – Каскадна модель ЖЦ  
 
Ця модель застосовується при розробці ПЗ, для якого  на самому 
початку розробки можна достатньо  точно і повно сформулювати всі 
вимоги.  
Переваги моделі : 
– на кожному етапі формується закінчений на бір документації, 
програмного та апаратного забезпечення, що відповідає критеріям п о-
вноти та узгодженості;  

10 
 
– стадії , що  виконуються в чіткій послідовності, дозволяють 
впевнено планувати терміни виконання робіт і відповідні ресурси 
(грошові, матеріальні і л юдські).  
Недоліки моделі:  
– реальний процес розробки ПЗ рідко повністю вкладається в 
таку жорстку схему. Особливо це від носиться до розробки нетипових 
та новаторських проєкт ів; 
– заснована на точному формулюванні вихідних вимог до ПЗ. 
Реально на початку проєкту вимоги замовника визначені лише час т-
ково;  
– основний недолік – результати розробки доступні замовнику 
тільки в кінці проєкт у. У разі неточного викладу вимог або їх зміни 
протягом тривалого періоду розробки  ПЗ замовник отримує систему, 
яка не задоволь няє його потребам.  
Інкрементна стратегія  припускає розробку інформаційної си с-
теми з лінійною послідовністю стадій, але в кілька інкрементів (ве р-
сій), тобто із запланованим поліпшенням продукту.  
 
 
Рисунок 1.3 – Інкрементна модель ЖЦ  
 
На початку роботи над проєкт ом визначаються всі основні в и-
моги до системи, після чого виконується її розробка у вигляді посл і-
довності версій. При цьому кожна версія є закінченим і працездатним 
продуктом. Перша версія реалізує частину запланованих можливо с-

11 
 
тей, наступна версія ре алізує додаткові можливості і т. д., поки не б у-
де отримана повна система.  
Дана модель ЖЦ характерна при розробці складних і комплек с-
них систем, для яких є чітке бачення (як з боку замовника, так і з боку 
розробника) того, яким має бути кінцевий результат. Розробка версі я-
ми ведеться з різних причин:  
– відсутність у замовника можливості відразу профінансувати 
весь проєкт  (за умови великої ціни);  
– відсутності у розробника необхідних ресурсів для реалізації 
складного проєкт у в стислі терміни;  
– вимоги поетапно го впровадження та освоєння продукту кінц е-
вими користувачами. Впровадження всієї системи відразу може в и-
кликати у її користувачів неприйняття і тільки «загальмувати» процес 
переходу на нові технології.  
Переваги і недоліки цієї стратегії такі ж, як і у кла сичної. Але на 
відміну від класичної стратегії замовник може раніше побачити р е-
зультати. Вже за результатами розробки та впровадження першої ве р-
сії він може незначно змінити вимоги до розробки, відмовитися від неї 
або запропонувати розробку більш досконало го продукту з укладе н-
ням нового договору.  
Спіральна стратегія  (еволюційна або ітераційна модель) п е-
редбачає розробку у вигляді послідовності версій, але на початку про-
єкту визначені не всі вимоги. Вимоги уточнюються в результаті ро з-
робки версій.  
Дана модел ь життєвого циклу характерна при розробці новато р-
ських (нетипових) систем. На початку роботи над проєкт ом у замо в-
ника і розробника немає чіткого бачення кінцевого продукту (вимоги 
не можуть бути чітко визначені) або стовідсоткової впевненості в у с-
пішній ре алізації проєкт у (ризики дуже великі). У зв'язку з цим при й-
мається рішення розробки системи по частинах з можливістю зміни 
вимог або відмови від її подальшого розвитку. Як видно з рис. 1.4 ро з-
виток проєкт у може бути завершено не тільки після стадії впров а-
дження, але і після стадії аналізу ризику.  
 
12 
 
 
Рисунок 1.4 – Спіральна модель ЖЦ  
 
Переваги моделі:  
– дозволяє якнайшвидше показати користувачам системи прац е-
здатний продукт, тим самим активізуючи процес уточнення і допо в-
нення вимог;  
– допускає зміну вимог пр и розробці інформаційної системи, що 
характерно для більшості розробок, в тому числі й типових;  
– забезпечує більшу гнучкість в управлінні проєкт ом; 
– дозволяє отримати більш надійну і стійку систему. В процесі  
розвитку системи помилки і слабкі місця виявл яються і виправляют ь-
ся на кожній ітерації;  
– дозволяє вдосконалювати процес розробки  – аналіз, що вико-
нується на  кожній ітерації, дозволяє проводити оцін ку того, що має 
бути змінено в організації розробки, та  поліпшити її на наступній іт е-
рації;  

13 
 
– зменшують ся ризики замовника. Замовник може з мінімал ь-
ними для себе фінансовими втратами завершити розвиток неперспе к-
тивного проєкт у. 
Недоліки моделі:  
– збільшується невизначеність у розробника в перспективах р о-
звитку проєкт у. Цей недолік випливає з попередньої пер еваги  моделі;  
– ускладнені операції часового і ресурсного планування всього 
проєкт у в цілому. Для вирішення цієї проблеми необхідно ввести ч а-
сові обмеження на кожну зі стадій життєвого циклу. Перехід здійсн ю-
ється відповідно до плану, навіть якщо не вся зап ланована робота в и-
конана. План складається на основі статистичних даних, отриманих в 
попередніх проєкт ах, і особистого досвіду розробників.  
Протягом  значного часу саме спіральна модель ЖЦ демонстр у-
вала найбільшу придатність. Проте , навіть такий підхід через недост а-
тню гнучкість потребував змін. Через це з часом з’явився окремий 
клас методологій розробки – гнучка розробка програмного забезп е-
чення.  
 
1.2.1.1  Гнучка розробка програмного забезпечення  
 
Гнучка розробка програмного забезпечення (agile -методи) від о-
кремилась  як клас методологій розробки програмного забезпечення, 
що базується на ітеративній розробці, в якій вимоги та розв'язки ев о-
люціонують через співпрацю між багатофункціональними командами , 
здатними до самоорганізації.  
Гнучка роз робка припускає, що при реалізації проєкт у не потр і-
бно спиратися тільки на заздалегідь створені докладні плани. Важливо 
орієнтуватися на постійно мінливі умови зовнішнього і внутрішнього 
середовища і враховувати зворотний зв'язок від замовників та кори с-
тувачів. Це заохочує розробників та інженерів експериментувати і 
шукати нові рішення, не обмежуючи себе жорсткими рамками і ста н-
дартами.  
До популярних  agile -підходів відносяться Scrum і Kanban.  
Scrum – це, так би мовити, «підхід структури». Над кожним про-
єктом працює універсальна команда фахівців, до якої приєднується ще 
дві людини: власник продукту і scrum -майстер. Перший з'єднує к о-
манду з замовником і стежить за розвитком проєкт у; це не формал ь-
ний керівник команди, а швидше куратор. Другий допомагає першому 
14 
 
організувати бізнес -процес: проводить загальні збори, вирішує поб у-
тові проблеми, мотивує команду і стежить за дотриманням scrum -
підходу.  
Scrum -підхід ділить робочий процес на рівні терміни ( спринти ) 
– зазвичай це періоди від тижня до місяця, залежно від проєкту і к о-
манди. Перед спринтом формулюються завдання на даний спринт, в 
кінці – обговорюються результати, а команда починає новий спринт. 
Спринти дуже зручно порівнювати між собою, що дозволяє управляти 
ефективністю роботи.  
Kanban же  – це «підхід балансу» . Його завдання – збалансувати 
різних фахівців усередині команди та  уникнути ситуації, коли  частині 
команди треба працювати постійно, а інша не може розпочати роботу 
через  відсутність нових завдань.  
В Kanban немає ролей власника продукту і scrum -майстра – вся 
команда єдина. Бізнес -процес ділиться не на універсальні спринти, а 
на стадії виконання конкретних завдань: « Планування », «Розробка », 
«Тестування », «Завершення » та ін.  
Головний показник ефективності в K anban  – середній час пр о-
ходження завдання по дошці . Завдання пройшло ш видко – команда 
працювала продуктивно і злагоджено. Завдання з атягнулося  – треба 
дума ти, на якому етапі та чому виникли затримки,  чию роботу треба 
оптимізувати.  
 
1.2.2 Аналіз вимог  
 
На сьогоднішній день, процес ЖЦ, на якому фіксуються вимоги 
на розробку системи, є визначальним для завдання функцій, термінів 
та вартості робіт, а також показників якості, яких необхідно досягти в 
процесі розробки. Висунення вимог проводиться шляхом обговорення 
проєкт у, аналізу предметної області та визначення під ходів до проє к-
тування проміжних продуктів на етапах ЖЦ.  
Вимоги відображають потреби людей (замовників, користув а-
чів, розробників), зацікавлених у створенні ПЗ. Замовник і розробник 
спільно проводять обговорення проблем проєкт у, збір вимог, їх аналіз, 
перег ляд, визначення необхідних обмежень і документування.  
Аналіз вимог  полягає у  визначенні потреб та умов , які висув а-
ються щодо нового, чи зміненого продукту, враховуючи можливо 
конфліктні вимоги різних замовників.  
15 
 
Аналі з вимог є критичним для успішного розроблення  проєкт у. 
Вимоги мають бути задокументованими, вимірними, тестов аними, 
пов'язаними з бізнес -потребами, і описаними з рівнем деталізації до с-
татнім для конструювання системи.  
 
1.2.3 Етапи аналізу вимог  
 
Аналіз вимог включає наступні види діяльності:  
Виявлення (збирання) вимог – задача комунікації з користув а-
чами для визначення їх вимог.  
Аналіз вимог – виявлення недоліків вимог (неточностей, непо в-
ноти, неоднозначностей чи суперечностей) і їх виправлення.  
Запис вимог – документування вимог в різних формах , таких як 
опис звичайною мовою, прецедентами, користувацькими історіями, чи 
специфікаціями процесу.  
 
1.2.4 Класифікація вимог  
 
Вимоги споживача  представляють собою вирази фактів та 
припущень , які описують очікування від  системи в термінах цілей, 
середо вища, обм ежень  та міри ефективності й придатності.  
Архітектурні вимоги  пояснюють , що має бути зроблено іде н-
тифікацією необхідної системної архітектури.  
Структурні вимоги  пояснюють , що має бути зроблено ідент и-
фікацією необхідної структури системи.  
Поведінкові вимоги  пояснюють , що має бути зроблено ідент и-
фікацією необхідної поведінки системи.  
Функціональні вимоги  пояснюють , що має бути зроблено ід е-
нтифікацією необхідної задачі, дії  чи діяльності , які мають виконув а-
тись. Аналіз функціональних вимог буде використа ний в функціях 
верхніх рівнів для функціонального аналізу.  
Нефункціональні вимоги  задають критерій для оцінювання  
операцій системи, замість її поведінки.  
Вимоги продуктивності  пояснюють, до якої міри місії чи фу н-
кції повинні бути виконані; зазвичай вимірює ться в термінах кілько с-
ті, якості, охоплення , своєчасності чи готовності. Протягом аналізу 
вимог, вимоги продуктивності будуть інтеракт ивно розроблятись 
впродовж всіх виявлених функцій,  що базуються на факторах житт є-
16 
 
вого циклу системи, і характеризуються в  термінах ступеня визнач е-
ності в їх оцінках, сту пеня критичності успіху системи  і їх відношення 
до інших вимог.  
Вимоги дизайну . 
Успадковані вимоги , тобто вимоги , які обумовлені  вимогами 
вищого рівня, чи перетворені з них.  
Розподілені вимоги  визначені поді лом чи іншим перерозм і-
щенням високорівневих вимог в декілька низькорівневих вимог.  
 
1.2.5 Користувацькі історії  
 
Користувацькі історії  – в гнучкій розробці термін, що трад и-
ційній розробці називають «програмні вимоги». Вони є короткими 
заявами про намір або в имог и до системи.  
Користувацькі історії (User Story) – спосіб опису вимог до ро з-
роблюваної систем и сформульованих як о дна або більше пропозицій 
повсякденною  або діловою мовою  користувача. Користувацькі історії 
використовуються гнучкими методологіями розробки ПЗ для спец и-
фікації вимог. Кожна користувацька історія обмежена за розміром та 
складністю . У методології Scrum історії пишуться  або схвалюються 
власником продукту . Для за мовників (користувачів) користувацькі 
історії є основним інструментом впливу на розробку програмного з а-
безпечення.  
Користувацькі історії – швидкий спосіб документувати вимоги 
клієнта, без необхідності розробляти великі формалізовані документи 
і згодом витр ачати ресурси на їх підтримку. Мета користувацьких і с-
торій полягає в тому, щоб бути в змозі оперативно і без накладних в и-
трат реагувати на мінливі вимоги реального світу.  
Ось основна формула написання історії користувача: Як <роль> 
я хочу <функція> щоб <кор исть>.  
Карта історії (story map)  є інструментом, що допомагає в осм и-
сленні функціональності продукту, способів його використання, а т а-
кож допомагає в розстановці пріоритетів при постачанні продукту 
(при плануванні релізу). Цей метод декомпозиції забезпечує  евол ю-
ційне розуміння продукту, починаючи з повного охоплення всіх по т-
реб і завершуючи зануренням до детальних історій користувачів.  
Карта історій служить джерелом інформації і використовується 
для візуалізації вимог до продукту в контексті використання та  пріо-
17 
 
ритетів. Карта історій часто виводиться на екран для проєкт ної кома н-
ди під час сесій планування релізу. Аналізуючи карту історій, команда 
може краще ідентифікувати залежності, що утворюються в результаті 
передбачуваного потоку через власні історії. К арта також може бути 
використана для оцінки і управління ризиками, шляхом розгляду того, 
як історії будуть спільно працювати в контексті отримання користі 
для бізнесу.  
Карта історій являє собою техніку візуального і фізичного пре д-
ставлення послідовності дій , які повинні бути реалізовані рішенням. 
При цьому використовується двомірна сітка, щоб показати послідо в-
ність і угруповання ключових аспектів продукту по горизонталі, а д е-
талі і пріоритет історій по вертикалі.  
Приклад побудови карти історій у випадку, ко ли перед кома н-
дою розробників стоїть задача створити інтернет -магазин для проду к-
ції продемонстровано у Додатку Б.  
 
1.2.6 Документування вимог  
 
Документ, який описує вимоги, є результатом етапів виявлення 
та аналізу вимог. Документ опису вимог розроблюється відповідно до 
раніше визначеного шаблону. Шаблон визначає структуру та стиль 
документу.  
Частина документу опису вимог, яка містить стислий опис про-
єкту, переважно орієнтує тих керівників та учасників проєкт у, які ві д-
повідні за прийняття рішення, але ймовір но не стануть детально в и-
вчати документ повністю. На початку документу необхідно визначити 
цілі та межі проєкт у, а потім описати діловий контекст системи.  
Також слід  визначити учасників проєкт у системи. При цьому 
важливо, щоб замовник виступав не як безвиразно представлений пі д-
розділ або офіс, необхідно привести конкретні імена.  
Хоча документ опису вимог може бути далеким від технічних 
рішень, важливо визначити ідеї, які стосуються рішення, на початк о-
вих етапах життєвого циклу розробки. Важливо також проаналізувати 
варіант придбання готового продукту замість його розроблення “з н у-
ля”. Документ опису вимог повинен надавати перелік існуючих пр о-
грамних компонентів та пакетів, які необхідно в подальшому вивчити 
в якості варіантів можливих рішень.  
18 
 
Основна ч астина документу опису вимог присвячена визначе н-
ню системних сервісів . Ця частина може займати до половини всього 
обсягу документу. Це єдина частина документу, яка може містити уз а-
гальнені моделі – моделі бізнес -вимог.  
Межі системи можна моделювати за допо могою діаграм ко н-
тексту. У поясненнях до діаграми контексту повинні бути чітко визн а-
чені межі системи. Без подібного визначення проєкт  не може бути з а-
страхованим від спроб “розтягнути” його межі.  
Функціональні вимоги можна моделювати за допомогою діаграм 
бізнес-прецедентів. Однак, діаграми охоплюють  перелік функціонал ь-
них вимог тільки в загальному вигляді. Усі вимоги треба позначити, 
класифікувати та визначити.  
Вимоги до даних можна моделювати за допомогою діаграми б і-
знес-класів. Так само як і у випадку фун кціональних вимог, діаграма 
бізнес -класів не дає повного визначення структур даних для бізнес -
процесів. Кожний бізнес -клас вимагає подальших пояснень. Необхі д-
но описати атрибут не наповнення класів та визначити ідентифікуючі 
атрибути класів. У протилежному випадку неможливо правильно 
представити асоціації.  
Системні сервіси  визначають, що повинна робити система. С и-
стемні обмеження виз начають, на скільки система  обмежена під час 
виконання обслуговування. Системні обмеження пов’язані з насту п-
ними видами вимог:  
 вимоги до інтерфейсу;  
 вимоги до продуктивності;  
 вимоги до безпеки;  
 експлуатаційні вимоги;  
 політичні та юридичні вимоги.  
Вимоги до інтерфейсу визначають, як система взаємодіє з кор и-
стувачем. У документі опису вимог визначаються тільки “відчуття” 
від GU I-інтерфейсу. Початкове проєкт ування GUI -інтерфейсу викон у-
ється під час специфікації вимог та пізніше під час системного проє к-
тування.  
У залежності від галузі застосування вимоги до продуктивності 
можуть грати доволі важливу роль в успіху проєкт у. В обмеженому 
розумінні вони  задають швидкість (час відгуку  системи), з якою п о-
винні виконуватися різноманітні завдання. У широкому розумінні в и-
19 
 
моги до продуктивності включають інші обмеження: щодо надійності, 
готовності, пропускної здатності тощо.  
Вимоги до  безпеки описують користувацькі права доступу до 
інформації, що контролюються системою. Користувачам може бути 
наданий обмежений доступ до даних або обмежені права на викона н-
ня деяких операцій з даними.  
Експлуатаційні вимоги визначають програмно -технічне серед о-
вище, якщо воно відоме на етапі проєкт ування, у якому повинна фу н-
кціонувати система. Ці вимоги можуть впливати на інші сторони про-
єкту, такі як: підготовка користувачів та супроводження системи.  
Важливі й інші види обмежень. Наприклад, у відношенні д еяких 
систем можуть висуватися вимоги щодо легкості їх використання (в и-
моги щодо придатності їх використання) або легкості їх супроводже н-
ня (вимоги щодо придатності до супроводження).  
Заключна частина документу опису вимог визначає інші проє к-
тні питання . Одним з важливих розділів даної частини є «Відкриті 
питання », у якому визначаються всі питання, які можуть вплинути на 
успіх проєкт у і які не розглядались в інших розділах документу. До 
даного пункту належить очікуване збільшення значення деяких вимог, 
які в поточний момент виходять за межі проєкт у, а також будь -які п о-
тенційні проблеми та відхилення у поведінці системи, які можуть п о-
чатися у зв’язку з розгортанням системи.  
У даній частині документу опису вимог необхідно представити 
попередній план -графік вик онання основних проєкт них завдань, а т а-
кож попередній розподіл людських та інших ресурсів. Для вироблення 
стандартних планових графіків можна використовувати програмні з а-
соби управління проєкт ами, наприклад, такі як система PERT (program 
evaluation -and-review technique – метод оцінювання та перегляду пл а-
нів) або карти Гантта.  
Прямим результатом складання план -графіку може бути розро б-
лення попереднього бюджету. Вартість проєкт у може бути виражена у 
вигляді діапазонів значень витрат, а не конкретного значення . 
Додатки до документу опису вимог містять іншу корисну для 
розуміння вимог інформацію. Основним додатком є глосарій. Глос а-
рій визначає терміни, скорочення та абревіатури, які використовуют ь-
ся в документі опису вимог. Значення вірно розробленого глосарію 
важко переоцінити. Невірне використання термінології несе велику 
небезпеку для проєкт у. 
20 
 
Розділ посилань  містить перелік документів, які згадуються та 
використовуються при підготовці документу  опису вимог. До них м о-
жуть належати книги та інші опубліковані джерела інформації, а т а-
кож внутрішні документи, які можливо є навіть більш важливими.  
 
1.3 Завдання на лабораторну роботу  
 
1.3.1  Ознайомитися з теоретичними відомостями, необхідними 
для виконання  роботи.  
1.3.2  Обрати тему для подальшого проєкт ування системи з п е-
реліку тем у Додатку А або запропонувати власну тему. Узгодити т е-
му з викладачем.  
1.3.3 Провести документування специфікації вимог до проєкт у: 
сформулювати цілі та межі проєкт у, аналіз функ ціональних вимог 
представити у вигляді  карти користувацьких історій, визначити уча с-
ників проєкт у та провести розподіл учасників проєкт у та ролей кори с-
тувачів , розглянути існуючі рішення проблеми.  
1.3.4  Визначити системні сервіси: межі системи, функціональн і 
вимоги, вимоги до даних.  
1.3.5  Сформулювати системні обмеження: вимоги до інтерфе й-
су, продуктивності, безпеки, експлуатаційні вимоги  та вимоги до клі є-
нтської та серверної сторін . 
1.3.6  Визначити проєкт ні питання: представити попередній 
план -графік викона ння основних проєкт них завдань, попередній б ю-
джет  (складається із заробітної платні учасників проєкт у), розглянути 
питання, які впливають на успіх проєкт у і не були розглянуті в інших 
пунктах.  
1.3.7  Оформити звіт з роботи.  
1.3.8  Відповісти на контрольні питання.  
 
1.4 Зміст звіту  
 
1.4.1  Тема та мета роботи.  
1.4.2  Тема, обрана для проєкт ування.  
1.4.3  Завдання на лабораторну роботу.  
1.4.4  Специфікація вимог до проєкт у: цілі та межі проєкт у, уч а-
сники проєкт у та ролі користувачів, функціональні вимоги до проєкт у, 
21 
 
карта користувацьких історій, існуючі аналоги, системні сервіси, си с-
темні обмеження, проєкт ні питання, додатки.  
1.4.6  Висновки, що містять відповіді на контрольні запитання, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  
 
1.5 Контроль ні запитання  
 
1.5.1  Що таке життєвий цикл?  
1.5.2  Поясніть різницю між життєвим циклом та методологією 
розробки . 
1.5.3 Які етапи життєвого циклу розробки систем розрізняють?  
1.5.4  Які існують методи виявлення вимог до програмного з а-
безпечення?  
1.5.5  Які фаз и включає процес аналізу вимог?  
1.5.6  Кого можна віднести до осіб, зацікавлених у розробці си с-
теми?  
1.5.7  Які існують способи документування вимог?  
1.5.8  Поясніть принцип складання карти користувацьких іст о-
рій? 
1.5.9  Які типи вимог можна виокремити?  
1.5.10  Які види ризиків характерні для вимог?  
1.5.11  Яка типова структура документу опису вимог?  
  
22 
 
2 ЛАБОРАТОРНА РОБОТА №  2  
ПРОЄКТ УВАННЯ ПРОГРАМНОГО 
ЗАБЕЗПЕЧЕННЯ З ВИКОРИСТАННЯМ UML  
 
2.1 Мета роботи  
 
Ознайомитися з видами діаграм UML та особливостями їх з а-
стосування  для проєктування програмного забезпечення , навчитися 
розробляти а бстрактну м одель програмно ї системи м овою UML на 
основі діаграм різних видів . 
 
2.2 Короткі теоретичні відомості  
 
UML (англ. Unified Modeling Language) – уніфікована мова м о-
делювання, що використовується у парадигмі об'єктно -орієнтованого 
програмування та є невід'ємною частиною уніфікованого процесу ро з-
роблення  ПЗ. UML заснована на діаграмах, що дають можливість 
представити систему у такому вигл яді, щоб її можна було легко пер е-
вести в програмний код.  
 
2.2.1 Діаграма класів  
 
Діаграму класів (class diagram) використовують для поданн я 
стати чної структури моделі системи в термінології класів об’єктно -
орієнтованого програмування.  
Класи використовуються для складання словника розроблюв а-
ної системи. Вони представляють опис сукупності об’єктів із загал ь-
ними атрибутами, операціями, відношеннями та семантикою. Клас 
реалізує один чи декілька інтерфейсів.  
Діаграми класів використо вуються для моделювання стати чного 
вигляду системи з точки зору проєкт ування. Сюди більшою мірою 
належить моделювання словника системи, кооперацій та схем. Діа г-
рами класів складають основу діаграм компонентів.  
Діаграми класів можуть містити  наступні сутності:  
 класи;  
 інтерфейси  – набори опер ацій, які використовуються для 
специфікації послуг, що надаються класом або компонентом ; 
23 
 
 кооперації  – спільнота класів, інтерфейсів та інших елеме н-
тів, які працюють спільно для забезпечення кооперативної поведінки, 
що є більш значимою ніж сума складових ; 
 відношення залежності  (описує існуючі між класами відн о-
шення використання) , узагальнення (зв’язує узагальнені класи зі сп е-
ціалізованими) та асоціації  (надає структурні відношення між 
об’єктами) . 
Залежністю називають варіант використання, відповідно до як о-
го зміна у специфікації одного елементу може вплинути на інший 
елемент, що його використовує, при чому зворотне не обов’язково. 
Графічно залежність позначається пунктирною лінією зі стрілкою, 
направленою від одного елементу на той, від якого він залежить.  Най-
частіше залежності застосовуються під час роботи з класами, щоб ві д-
бити у сигнатурі операції той факт, що один клас використовує інший 
у якості аргументу.  
Узагальнення – відношення між загальною сутністю (суперкл а-
сом, або батьківським класом) та її конкр етним втіленням (субкласом, 
чи нащадком). Узагальнення іноді називають відношенням типу “є”, 
маючи на увазі, що одна сутність є окремим вираженням іншої, більш 
загальної. Узагальнення означає, що об’єкти класу -нащадка можуть 
використовуватися всюди, де зус трічаються об’єкти батьківського 
класу, але не навпаки.  Нащадок наслідує властивості батьківського 
класу, зокрема його атрибути та операції.  
Проста асоціація між двома класами відбиває структурне ві д-
ношення між рівноправними сутностями, коли обидва класи з нахо-
дяться на одному концептуальному рівні і не один з них не є більш 
важливим ніж інший. Але іноді треба змоделювати відношення типу 
“частина/ціле”, в якому один з класів має більш високий ранг (ціле) і 
складається з декількох менших за рангом (частин). В ідношення так о-
го типу називається агрегацією. Агрегація є окремим випадком асоц і-
ації. 
Часто під час моделювання важливо зазначити, скільки об’єктів 
може бути пов’язано шляхом одного екземпляру асоціації. Це число 
називається кратністю ролі асоціації і запи сується або як вираз, зн а-
ченням якого є діапазон значень, або у явному вигляді.  
Приклад ді аграми класів наведено на рис.  2.1. 
 
24 
 
 
 
Рисунок 2 .1 – Діаграма класів  
 
2.2.2 Діаграма компонентів  
 
Діаграма компонентів (рис.  2.2) описує особливості фізичної у я-
ви системи. Дана діаграма застосовується для моделювання статичн о-
го вигляду системи з точки зору реалізації. За своєю сутністю діагр а-
ми компонентів – не що інше як діаграми класів, сфокусовані на си с-
темних компонентах.  
Діаграма компонентів відображає залеж ності між компонентами 
ПЗ, включаючи компоненти вихід них кодів, бінарні компоненти  та 

25 
 
компоненти, що можуть виконуватись, тобто вона дозволяє визначити 
архітектуру системи, що розробляється, встановивши залежності між 
програмними компонентами.  
Діаграми компонентів зазвичай включають:  
 компоненти;  
 інтерфейси;  
 відношення узагальнення, асоціації та реалізації.  
Реалізацією називається семантичне відношення між класифік а-
торами, за якого один з них описує контракт, а інший гарантує його 
виконання.  Частіше за вс е реалізації використовуються для визначе н-
ня відношень між інтерфейсом та класом або компонентом, який н а-
дає об’явлені в інтерфейсі операції або послуги.  
 
 
 
Рисунок 2 .2 – Діаграма компонентів  
 
2.2.3 Діаграма прецедентів  
 
Діаграми прецедентів застосовуються для моделювання вигляду 
системи з точки зору прецедентів (або варіантів використання). Даний 
вид діаграм використовується для моделювання динамічних аспектів 
системи, так само як і діаграми станів та діяльності.  
Діаграма прецедентів – діаграма, на якій зображе но відношення 
між акторами та прецедентами в системі (рис.  2.3). 
Діаграми прецедентів зазвичай включають в себе:  
 прецеденти;  
 акторів;  
 відношення залежності, узагальнення та асоціації.  

26 
 
UML дозволяє моделювати контекст за допомогою прецедентів, 
у яких особлива увага акцентується акторів, що оточують систему. 
Важливо вірно визначити акторів, оскільки це дозволяє описати клас 
сутностей, що взаємодіють з системою.  
Моделювання контексту системи складається з наступних кр о-
ків: 
а) ідентифікувати  акторів , що оточ ують систему: визначити  
групи, яким участь системи необхідна для виконання їхніх завдань; 
групи, які необхідні для виконання системою своїх функцій; групи, 
що взаємодіють із зовнішніми програмними та апаратними засобами, 
а також групи, що виконують допоміж ні функції адміністрування та 
підтримки;  
б) організувати  схожих акторів за допомогою відношень уз а-
гальнення/спеціалізації;  
в) ввести  стереотипи для кожного актор а, якщо це полегшує р о-
зуміння;  
г) розташувати  акторів на д іаграмі прецедентів та визначити  
способи їх зв’язку  з прецедентами системи.  
 
 
Рисунок 2.3 – Діаграма прецедентів  

27 
 
Проєкт ована система представляється у вигляді множини сутн о-
стей чи акторів, що взаємодіють  із системою за допомогою варіантів 
використання (use case), призначених  для опису сервісів, що система 
надає актору. Іншими словами, кожен варіант використання визначає 
деякий набір дій системи при діалозі з актором.  
 
2.2.3.1  Потоки подій  
 
Однією з вимог мови UML є самодостатність діаграм для п о-
дання інформації про моделі проєкт ованих систем. Однак, діаграм и 
прецедентів описують те, що робить система, без уточнення того, як 
вона це робить.  
Для реального опису системи потрібні специфічні дані, які від о-
бражені в потоці подій. Потоки подій уточнюють або деталізують п о-
слідовність дій, які здійснюються системою при виконанні її варіантів 
використання, а також описують логіку переходів через варіанти в и-
користання.  
Потік подій – це певна послідовність дій, яка описує дії акторів 
і поведінку модельованої системи в формі звичайного тексту.  
Потоки подій – це текстов і описи покрокового виконання пр е-
цедентів, вони зрозумілі не тільки розробнику, але і сторонньому ч и-
тачеві. Їх завдання – ще більше деталізувати опис функціональності 
системи до того, як розробники приступлять до написання програмн о-
го коду, і усунути можли ве нерозуміння необхідної функціональності, 
як можна більше зблизити уявлення розробника про систему і замо в-
ника.  
Потоки подій бувають трьох типів: основний, альтернативний і 
потік помилок.  
Основний (головний) потік  описує найкращий сценарій або 
найбільш використовуваний шлях виконання прецеденту.  
Альтернативний потік  специфікує відхилення від основного 
потоку, які не розглядаються як помилкові.  
Потік помилок  розглядається як відхилення від альтернативн о-
го або осно вного, яке породжує умови формування помилки.  
Приклад опису потоку подій наведено у Додатку В.  
 
 
28 
 
2.2.4 Діаграма станів  
 
Діаграми станів (рис.  2.4) зображають всі можливі стани, в яких 
може знаходитися конкретний об'єкт, а також зміни стану об'єкту, які 
відбуваю ться в результаті впливу деяких подій на цей об'єкт. У біл ь-
шості об'єктно -орієнтованих методів діаграми станів будуються для 
єдиного класу, щоб показати динаміку поведінки єдиного об'єкту.  
Зазвичай діаграми станів складаються з наступних елементів:  
 прості та складені стани;  
 переходи разом з асоційованими подіями та діями.  
 
 
 
Рисунок 2. 4 – Іменовані переходи між станами  
 
2.2.5 Діаграма діяльності  
 
Діаграма діяльності показує переходи між видами діяльності. 
Модель видів діяльності (activity model) може подавати в графічній 
формі потік подій для прецеденту (рис. 2. 5).  

29 
 
Кожен прецедент можна моделювати за допомогою одного або 
декількох графів видів діяльності. Діаграма діяльності за своєю сутн і-
стю є блок -схемою, яка демонструє, як потік управління переходить 
від одні єї діяльності до іншої.  
Подія, джерелом якої служить суб'єкт -прецедент, що ініціює, це 
та ж сама подія, що запускає виконання графа видів діяльності. Пр о-
цес виконання послідовно переходить від одного стану виду діяльно с-
ті до іншого.  
Діаграма діяльності у з агальному випадку складається зі:  
 станів діяльності та станів дії;  
 переходів.  
 
 
 
Рисунок 2. 5 – Діаграма діяльності  
 
Перехід – це відношення між двома станами, що демонструє те, 
що об’єкт, який знаходиться в першому стані, повинен виконати деякі 
дії та перейти у другий стан, як тільки відбудеться вказана подія та 
будуть задоволені вказані умови.  

30 
 
Розгалуження описує різноманітні шляхи виконання в залежн о-
сті від значення деякого булівського виразу.  
Послідовні переходи в діаграмах діяльності виконуються най ча-
стіше, однак використовуються також і паралельні потоки. У UML для 
позначення розділення та злиття таких паралельних потоків викона н-
ня використовується синхронізаційна лінія, яка зображується у вигл я-
ді жирної вертикальної або горизонтальної лінії.  
 
2.2.6 Діагр ама кооперації  
 
Діаграма кооперації (рис.  2.6) призначена для специфікації 
структурних аспектів взаємодії. Головна особливість діаграми кооп е-
рації полягає в можливості графічно уявити не тільки послідовність 
взаємодії, але і всі структурні відносини між об 'єктами, що беруть 
участь в цій взаємодії.  
Для створення діаграм кооперації необхідно розташувати 
об’єкти, що беруть участь у взаємодії, у вигляді вершин графа. Потім 
зв’язки, що з’єднують ці об’єкти, відображаються у вигляді дуг даного 
графу. Зв’язки допо внюються повідомленнями, які об’єкти приймають 
та посилають.  
Діаграма кооперації має дві властивості, які відрізняють її від 
діаграми послідовності:  
а) шлях: для опису зв’язку одного об’єкта з іншим до дальньої 
кінцевої точки цього зв’язку можна приєднати сте реотип шляху (н а-
приклад, local показує, що зазначений об’єкт є локальним по відн о-
шенню до відправника повідомлення); має сенс явним чином зображ а-
ти шлях зв’язку тільки по відношенню до шляхів типу local, parameter, 
global та self;  
б) порядковий номер повідомл ення: для позначення часової 
послідовності перед повідомленням можна поставити номер, який п о-
винен поступово збільшуватись для кожного нового повідомлення; 
для позначення вкладеності використовується десяткова нотація Дьюї.  
Найчастіше моделюються нерозгалу жені послідовності потоків 
управління. Однак можливо моделювати і більш складні потоки, що 
містять ітерації та розгалуження.  
 
31 
 
 
 
Рисунок 2. 6 – Діаграма кооперації  
 
2.2.7 Діаграма послідовності  
 
Діаграма послідовності показує учасників взаємодій і послідо в-
ність повідомлень, якими вони обмінюються.  
На діаграмі послідовності (рис.  2.7) зображуються виключно ті 
об'єкти, що безпосередньо беруть участь у взаємодії і не показуються 
можливі статичні асоціації з іншими об'єктами. Для діаграми послід о-
вності ключовим момен том є саме динаміка взаємодії об'єктів у часі.  
Для створення діаграми послідовності потрібно, по -перше, ро з-
ташувати об’єкти, що беруть участь у взаємодії, у верхній її частині 
вздовж вісі Х. Зазвичай об’єкт, що ініціює взаємодію, розташовують 
зліва, а інші  – правіше (чим далі, тим більш підпорядкованим є 
об’єкт). Потім вздовж вісі Y розташовують повідомлення, які об’єкти 
надсилають та приймають, при чому пізніші розташовуються нижче. 
Це надає наочну картину, яка дозволяє зрозуміти розвиток потоку к е-
рування в часі.  
Діаграми послідовності характеризуються двома особливост я-
ми, які відрізняють їх від діаграм кооперації.  
По-перше, на них є лінія життя об’єкту – вертикальна пунктирна 
лінія, що відбиває існування об’єкту в часі. Більша частина об’єктів, 
представлен их на діаграмі, існує протягом всієї взаємодії, тому їх з о-
бражують у верхній частині діаграми, а їх лінії життя промальовані 
згори донизу.  
Об’єкти можуть створюватись і під час взаємодії. Лінія життя 
таких об’єктів починаються з отримання повідомлення зі с тереотипом 
create. Об’єкти можуть також знищуватись під час взаємодії: у такому 
випадку їх лінії життя завершуються отриманням повідомлення зі ст е-
реотипом destroy, а в якості візуального образу використовується в е-
лика літера Х, що позначає кінець життя об’ єкту.  

32 
 
 
 
Рисунок 2. 7 – Діаграма послідовностей  
 
Друга особливість – фокус керування. Він позначається витя г-
нутим прямокутником, що показує проміжок часу, протягом якого 
об’єкт виконує деяку дію безпосередньо або за допомогою підпоря д-
кованої процедури. Верх ня грань прямокутника вирівнюється за час о-
вою віссю з моментом початку дії, нижня – з моментом його заве р-
шення. Вкладеність фокусу керування, викликану рекурсією або зв о-
ротним викликом з боку іншого об’єкту, можна продемонструвати, 
розташувавши інший фокус  керування правіше свого батьківського 
об’єкту.  
 

33 
 
2.3 Завдання на лабораторну роботу  
 
2.3.1 Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
2.3.2 Вивчити правила побудови структурних діаграм: діаграм 
класів, компонентів, розгортання, об’єктів, профілів, кооперації.  
2.3.3 Вивчити правила побудови діаграм поведінки: діаграм ді я-
льності, станів, прецедентів.  
2.3.4 Вивчити правила побудови діаграм взаємодії: діаграм ко о-
перації, послідовності, синхронізації, огляду взаємодії.  
2.3.5 Розробити  абстрактну модель системи за обраною темою 
на основі діаграми класів.  
2.3.6 Розробити абстрактну модель системи за обраною темою 
на основі діаграми компонентів.  
2.3.7 Розробити абстрактну модель системи за обраною темою 
на основі діаграми прецедентів.  
2.3.8 Розробити діаграми прецедентів для представлення варіа н-
тів використання системи, наведених на загальній діаграмі прецеде н-
тів. 
2.3.9 До діаграм прецедентів додати словесний опис потоків п о-
дій (включаючи опис основних, альтернативних та помилкових пот о-
ків). 
2.3.10 Розробити абстрактну модель системи за обраною темою 
на основі діаграми діяльності.  
2.3.11 Розробити абстрактну модель системи за обраною темою 
на основі діаграми станів  одного з класі в (який створюється і змін ю-
ється в одному або декількох прецед ентах) . 
2.3.12  Розробити абстрактну модель системи за обраною темою 
на основі діаграм кооперації  основного процесу системи . 
2.3.13  Розробити абстрактну модель системи за обраною темою 
на основі діаграм послідовності  основного процесу системи . 
2.3.14  Оформи ти звіт з роботи.  
2.3.15  Відповісти на контрольні питання.  
 
2.4 Зміст звіту  
 
2.4.1 Тема та мета роботи.  
34 
 
2.4.2 Тема, обрана для проєкт ування.  
2.4.3  Діаграма класів системи, що проєкт ується.  
2.4.4  Діаграма компонентів системи, що проєкт ується.  
2.4.5 Діаграма дія льності системи, що проєкт ується.  
2.4.6  Діаграма станів одного з класів (який створюється і змін ю-
ється в одному або декількох прецедентах) . 
2.4.7  Діаграми прецедентів системи, що проєкт ується.  
2.4.8 Опис потоків подій (включаючи опис основних, альтерн а-
тивних та помилкових потоків).  
2.4.9  Діаграма кооперації основного процесу системи . 
2.4.10  Діаграма послідовності основного процесу системи . 
2.4.11  Висновки, що містять відповіді на контрольні запитання, 
а також відображають результати виконання роботи та їх критичний 
аналіз.  
 
2.5 Контрольні запитання  
 
2.5.1 Які види структурних діаграм розрізняють в UML?  
2.5.2 З якою метою використовуються діаграми класів?  
2.5.3 Що таке структурні класи?  
2.5.4 Які види зв’язків між сутностями на діаграмах класів пре д-
ставлені в  UML?  
2.5.5 Який вид відношень між класами позначають асоціації , і 
які види асоціацій розрізняють?  
2.5.6 Відношення узагальнення між класами належить до часу 
проєкт ування чи до часу виконання?  
2.5.7 Які типи відношення залежності між класами розрізняють і 
яке вони мають значення?  
2.5.8 Яку інформацію несуть діаграми компонентів?  
2.5.9 З яких точок зору розглядається система в діаграмах кл а-
сів, об’єктів та компонентів?  
2.5.10  Для чого застосовуються діаграми компонентів?  
2.5.11  Що таке потік подій?  
2.5.12 Які види структурних діаграм можуть бути застосовані 
для моделювання фізичних баз даних?  
2.5.13 Які види діаграм взаємодії розрізняють в UML?  
2.5.14  Які види діаграм в UML використовуються для модел ю-
вання динамічних аспектів системи?  
35 
 
2.5.15 За яким фактором впорядковується взаємодія об’єктів на 
діаграмах послідовності?  
2.5.16 Чим відрізняються діаграми кооперації від діаграм посл і-
довності?  
2.5.17  Що таке сценарій в термінах діаграм послідовності?  
2.5.18  Що таке лінія життя об’єкту і як вона позначається на ді а-
грамі послідовності?  
2.5.19  Що таке фокус керування і як він позначається на діагр а-
мі послідовності?  
2.5.20  Скільки фокусів керування може мати об’єкт протягом 
своєї лінії життя?  
2.5.21  Хто може ініціювати взаємодію в системі?  
2.5.22  Які існують різновиди  повідомлень в UML?  
2.5.23  Які види діаграм поведінки розрізняють в UML?  
2.5.24  Які аспекти поведінки системи моделюються в діаграмах 
поведінки?  
2.5.25  З чого складається діаграма діяльності?  
2.5.26  Якими спільними з іншими видами діаграм властивост я-
ми вол одіє діаграма поведінки?  
2.5.27  Для чого використовуються діаграми діяльності?  
2.5.28  Для моделювання яких об’єктів використовуються діа г-
рами стану?  
2.5.29  Яке значення мають терміни “автомат”, “стан”, “подія”, 
“перехід”, “діяльність”, “дія” в сенсі діагра ми стану?  
2.5.30  Наведіть приклади застосування діаграм прецедентів.  
2.5.31  Які елементи включають в себе діаграми прецедентів?  
 
  
36 
 
3 ЛАБОРАТОРНА РОБОТА №  3  
ПРОЄКТ УВАННЯ ІНТЕРФЕЙСУ  
ВЕБ ЗАСТОСУНКІВ  
 
3.1 Мета роботи  
 
Навчитися проєкт увати ди зайн та інтерфейс  користувача вебза-
стосунків , враховуючи вимоги до інтерфейсу замовника та ергон оміч-
ні показники інтерфейсу.  
 
3.2 Короткі теоретичні відомості  
 
Інтерфейс (від англ. Interface – поверхня розділу, перегородка) – 
сукупність засобів і методів взає модії між елементами системи. Зал е-
жно від контексту, поняття застосовне як до окремого елементу (інт е-
рфейс елементу), так і до зв'язків елементів (інтерфейс сполучення 
елементів).  
Інтерфейс користувача – сукупність засобів, за допомогою яких 
користувач сп ілкується з різними пристроями:  
– інтерфейс командного рядка – управління  програмою або пр и-
строєм здійснюються шляхом введення з клавіатури текстових рядків;  
– графічний інтерфейс – управління програмними функціями 
реалізовано графічними елементами екрану.  
Спочатку термін «інтерфейс» застосовувався до всіх видів вза є-
модії людини і машини. Протягом багатьох років йшов розвиток ко м-
п'ютерів і мобільних пристроїв і сьогодні цей термін найчастіше озн а-
чає графічний інтерфейс користувача  (GUI).  
Графічний інтерфейс  користувача забезпечує зручний спосіб 
взаємодії з електронними пристроями за допомогою значків, кнопок і 
інших графічних елементів (порівняно з текстовими консольними і н-
терфейсами, які набагато складніше використовувати).   
 Дизайн інтерфейсу  користувача  (UID) або інжиніринг інте р-
фейсу – це дизайн інтерфейсу користувача (UI)  програм і пристроїв, 
таких як: комп'ютери, побутова техніка, мобільні телефони та інші 
електронні пристрої з акцентом на якість досвіду використання. М е-
тою дизайну інтерфейсу користувач а є створення максимально про с-
37 
 
того і продуктивного взаємодії з точки зору досягнення цілей кори с-
тувача (орієнтований на користувача дизайн).  
Багато кількісних та евристичних методів використовуються для 
аналізу та вивчення інтерфейсів. Кількісні методи час то можуть зв о-
дити спірні питання до простих обчислень. Ще однією, більш важл и-
вою, перевагою даних методів є те, що вони допомагають зрозуміти 
найважливіші аспекти взаємодії людини з машиною.  
 
3.2.1 Модель GOMS  
 
Класична модель GOMS – «правила для цілей, об'єктів , методів і 
виділення» (the model of goals, objects, methods, and selection rules) – 
дозволяє передбачити, скільки часу буде потрібно досвідченому кор и-
стувачеві на виконання конкретної операції при використанні даної 
моделі інтерфейсу.  
GOMS розділяє взаєм одію користувачів з комп'ютером на ел е-
ментарні дії (ці дії можуть бути фізичними, пізнавальними або діями 
сприйняття). Інтерфейс досліджується за допомогою цих елемента р-
них ді й. 
Хоча для різних користувачів час виконання того чи іншого ж е-
сту може суттєво р ізнитися, дослідники виявили, що для більшої ча с-
тини порівняльного аналізу задач, що включають використання клав і-
атури та графічного пристрою вводу, замість проведення вимірів для 
кожного окремого користувача можна використати набір стандартних 
інтервалів.  Так, наприклад, в оригінальній номенклатурі на натисне н-
ня клавіші відводиться 0.2 с, 1.1 с – час, необхідний користувачу для 
того, щоб вказати на якусь позицію на екрані монітору, 0.4 с – час, 
необхідний користувачу для того, щоб перемістити руку з клавіа тури 
на графічний пристрій виводу або навпаки, 1.35 с – час, необхідний 
користувачу для того, щоб розумово підготовитись до наступного 
кроку, R – час, протягом якого користувач повинен очікувати відп о-
відь комп’ютера. На практиці вказані значення можуть вар іюватися в 
широких інтервалах. Для досвідченого користувача, який може друк у-
вати зі швидкістю 135 слів/хв., час на натиснення клавіші може стано-
вити 0.08 с, для звичайного користувача, що має швидкість 55 слів/хв., 
– 0.2 с. Окрім того швидкість набору зале жить і від того, що саме н а-
бирається.  
38 
 
Тим не менш, за допомогою типових значень можна виконати 
правильне порівняльне оцінювання між двома інтерфейсами за рівнем 
ефективності їх використання.  
Тривалість відповіді від комп ’ютера може призводити до неоч і-
кува ного ефекту на дії користувача. Якщо в процесі використання 
якогось керуючого елементу на екрані монітору протягом приблизно 
250 мс нічого не відбувається, користувач, швидше за все, почне ві д-
чувати неспокій, вирішить зробити ще одну спробу або зробить пр и-
пущення, що система несправна. Якщо затримки неминучі, важливо, 
щоб в інтерфейсі б ув передбачений зворотний зв’язок, що повідомляє 
про них  користувачу . 
Розроблення інтерфейсу починається з визначення задач або н а-
бору задач, для яких продукт призначений. Об числення часу, необхі д-
ного для виконання тієї чи іншої дії, за допомогою моделі GOMS п о-
чинається з перелічення операцій зі списку жестів моделі GOMS, які 
входять до даної дії.  
 
3.2.2 Закон Фіттса  
 
Закон Фіттса свідчить, що час досягнення мети зворотно -
пропорцій ний розміру цілі та дистанції до неї. Закон Фіттса – загал ь-
ний закон, що стосується сенсорно -моторних процесів, він зв'язує час 
руху з точністю руху і з відстанню переміщення: чим далі чи точніше 
виконується рух, тим більше корекції необхідно для його вико нання і, 
відповідно, більше часу потрібно для внесення цієї корекції.  
В інтерфейсі програми довжина прямої лінії, що з'єднує поча т-
кову позицію курсора і найближчу точку цільового об'єкта, визнач а-
ється у законі Фіттса як дистанція. На основі даних про розмі ри об'є к-
ту і дистанції закон Фіттса дозволяє знайти середній час, за який к о-
ристувач зможе перемістити курсор до кнопки.  
Математично закон записується таким чином:  
  1 log2WDbaT
, 
де T – середній час, що витрачається на вчинення дії;  
a – середній час запуску / зупинки руху;  
b – величина, що залежить від типової швидкості руху;  
39 
 
D – дистанція від точки старту до центру цілі;  
W – ширина цілі, виміряна уздовж вісі руху.  
Для приблизних обчислень можна використати наступні зн а-
чення констант: a = 50, b = 150.  
 
3.2.3 Закон Хіка  
 
Закон Хіка говорить про те, що чим менше елементів меню, тим 
менше часу займає вибір одного з них.  
Перед тим як перемістити курсор до мети або вчинити будь -яку 
іншу дію з набору множини  варіантів, користувач повинен вибрати 
цей об'єкт або дію. У законі Хіка стверджується, що коли необхідно 
зробити вибір з n варіантів, час на вибір одного з них буде пропорці й-
ним логарифму за основою 2 від числа варіантів плюс 1 за умови, що 
всі варіанти є рівно ймовірними. У даному вигляді закон  Хіка схожий 
на закон Фіттса:  
2log ( 1) T a b n  
. 
Якщо ймовірність першого варіанту дорівнює pi, то замість л о-
гарифмічного коефіцієнту використовується:  




 n
i iipp H
12 11log
, 
де pi означає ймовірність i-го варіанту за умови теоретико -
інформаційної ентропії.  
Якщо варіанти для вибору представлені незрозумілим чином, 
значення a і b зростають. Наявність навичок і звичок у користувача 
при використанні системи знижує значення b. 
 
3.2.4 Етапи проєкт ування та інструменти розроблення д и-
зайн у інтерфейсу користувача  
 
Процес  проєкт ування дизайну інтерфейсу користувача можна 
спробувати розділити на етапи бага тьма способами. Проте найчастіше 
розділення відбувається за точністю представлення та характерними 
рисами, які відображаються. Такий розпод іл дає змогу оцінити хара к-
теристики розроблюваного шаблону та чітко відокремити інструме н-
40 
 
тарій розроблення шаблону інтерфейсу користувача. Так виділяють 
поняття: вайрфрейм, прототип та мокап.  
Вайрфрейм  – це низько деталізоване представлення  дизайну. 
Вайрфр ейм повинен  чітко демонструвати : 
– основні групи вмісту ; 
– інформаційну структуру ; 
– опис взаємодії користувача з інтерфейсом і його приблизну в і-
зуалізацію . 
Вайрфрейм можна розглядати як  скелет дизайну . Важливо т а-
кож відзначити, що в вайрфреймі  повинні бут и представлені всі ва ж-
ливі елементи кінцевого продукту.  
Тобто, вкрай важливо підтримувати  правильний баланс між рі в-
нем деталізації і швидкістю створення. Потрібно створити цілісне у я-
влення кінцевого дизайну та не пропустити жодного важливого ел е-
мента , але не потрібно вдаватися у деталі . На цьому етапі  описуєт ься 
фронт робіт по проєкт у для всіх задіяних осіб: розробників, дизайн е-
рів, копірайтерів, менеджерів — всім їм потрібен добре спроєкт ований  
вайрфрейм. Вайрфрейми повинні створюватися швидко і більшу ча с-
тину цього часу слід провести за обговореннями з командою і розд у-
мами. Зовнішній вигляд повинен бути естетичним, але дуже простим. 
Чорно -сіро-білий — типова палітра вайрфрейма.  
Якщо, наприклад, вибір піктограм або завантаження картинок 
займає занадто багат о часу , їх можна замінити заглушками. Вважаєт ь-
ся, що вайрфрейм дає неповне уявлення про кінцевий результат.  Хо-
роший вайрфрейм лягає в основу чистового ди зайну та  визначає н а-
прям роботи для всієї команди.  
Зазвичай вайрфрейми використовуються як документація  по 
проєкт у. Так як вони показують взаємодію користувача з інтерфейсом 
в окремих статичних моментах, їх потрібно супроводжувати текст о-
вими коментарями: як короткими поясненнями, так і комплексної те х-
нічною  документацією.  Приклад розроблення вайрфрейму для голо в-
ної сторінки інтернет -магазину наведено на рис. 3.1.  
 
41 
 
 
Рисунок 3.1 – Приклад розроблення вайрфрему  
 
Прототип – це середньо або високо деталізоване уявлення кі н-
цевого продукту, яке імітує взаємодію користувача з інтерфейсом. Він 
повинен дозволяти користувачеві:  
– оцінити зміст і інтерфейс;  
– протестувати основні способи взаємодії, як якщо б це був г о-
товий продукт.  
Прототип – це імітація взаємодії користувача з інтерфейсом кі н-
цевого продукту. Він може не виглядати точно як кінцевий продукт, 
але безу мовно не повинен бути контуром у відтінках сірого. Взаємодії 
повинні бути акуратно змодельовані та бути максимально схожими на 
те, що буде представлено в кінцевому продукті.  
Прототипи зазвичай не дуже підходять для документації, так як 
зрозуміти роботу ін терфейсу можна тільки в процесі взаємодії з пр о-
тотипом. З іншого боку, прототип – це найбільш приваблива форма 
документування дизайну, так як інтерфейс представляється «як є ». 
Приклад розроблення прототипу для головної сторінки інтернет -
магазину наведено н а рис. 3.2.  
Лого Головна Каталог Акції Зв’язокЛогін
ПарольКнопка
Кошик
ФільтриФото
ТекстФото
ТекстФото
ТекстФото
ТекстФото
Текст
Фото
ТекстФото
ТекстФото
ТекстФото
ТекстФото
Текст
Фото
ТекстФото
ТекстФото
ТекстФото
ТекстФото
Текст
Головна сторінка 
для ПК
42 
 
 
Рисунок 3.2 – Приклад розроблення прототипу  
 
Мокап – це середньо або високо деталізоване статичне уявле н-
ня дизайну. Дуже часто мокап – це чернетка дизайну або навіть фа к-
тичний дизайн -макет. Хороший мокап повинен:  
– чітко представляти інформац ійну структуру, візуалізувати к о-
нтент і демонструвати базову функціональність в статиці;  
– заохочувати оцінку візуальної сторони проєкт у. 
Мокапи підходять для отримання схвалення від зацікавлених 
осіб, не залучених в розробку , оскільки за вдяки візуальн ій природ і 
мокап сприймається легше, ніж низько деталізовані артефакти, і при 
цьому створюється швидше за прототип. Вони хороші для збору ві д-
гуків, і їх можна використовувати в документації.  Приклад розро б-
лення прототипу для головної сторінки інтернет -магазину  наведено на 
рис. 3.3.  
Головнаlogin
******
ФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
Текст
ФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
Текст Головна сторінка 
для ПК
Інтернет-магазин «Покупка»(000) 000 00 00
(000) 000 00 00
Каталог Акції Контакти
Рівень 1
· Рівень 2
· Рівень 2
        - Рівень 3
Рівень 1
· Рівень 2
· Рівень 2
        - Рівень 3
Рівень 1
· Рівень 2
· Рівень 2
        - Рівень 3
Рівень 1
· Рівень 2
· Рівень 2
        - Рівень 3
Рекламний банерШрифт: Mistral
Розмір: 30Шрифт: Book Antiqua
Розмір: 18
Шрифт: Book Antiqua
Розмір: 24Шрифт: Mistral
Розмір: 14
Напівжирний
Не більше 10 об’єктів Шрифт: Book Antiqua
Рівень 1 - розмір: 12
Рівень 1 - розмір: 10
Рівень 1 - розмір: 10
43 
 
 
Рисунок 3.3 – Приклад розроблення мокапу  
 
Порівняння методів проєкт ування дизайну представле ні у в и-
гляді таблиці 3.1.  
 
Таблиця 3.1 – Порівняння етапів та інструментарію розроблення 
дизайну інтерфейсу користувача  
 Точність  
представлення  Основні риси  Застосування  
Вайрфрейм  низька  монохромний 
ескіз  програмна докум е-
нтація  
Прототип  висока  інтерактивність, 
найповніше від о-
браження  каркас для розро б-
ки, проходження 
тестування дизайну  
Мокап  середня  статична візуал і-
зація  затвердження у з а-
цікавлених сторін  
 
 
3.3 Завдання на лабораторну роботу  
 
3.3.1 Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
Головне 
менюlogin
******
ФільтриФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
Текст
ФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
ТекстФотоФото
Текст Головна сторінка 
для ПК
Назва магазинуКонтактна інформація
Головне 
менюГоловне 
менюГоловне 
меню
Рекламний банерЛого
44 
 
3.3.2 Проаналізувати вимоги до інтерфейсу ПЗ на основі спец и-
фікації  вимог  до ПЗ . 
3.3.3 Визначити особливості роботи кожної групи користувачів 
з кожним елемен том взаємодії користувача з веб застосунк ом. 
3.3.4 Розробити повний прототип головної сторінки системи 
(включаючи кольорові схеми, шрифти та їх розміри, оформлення для 
елементів керування ), використо вуючи Photoshop або аналогічні гр а-
фічні редактори . 
3.3.5  Розробити вайрфрейми інших сторінок,  що реалі зують р о-
боту  систем и. 
3.3.6  Обґрунтувати вибір запропонованих елементів інтерфейсу, 
ґрунтуючись на вимогах до інтерфейсу та ергономічних показниках 
інтерф ейсу.  
3.3.7  Оформити звіт з роботи.  
3.3.8  Відповісти на контрольні питання.  
 
3.4 Зміст звіту  
 
3.4.1 Тема та мета роботи.  
3.4.2 Тема, обрана для проєкт ування.  
3.4.3 Загальна схема роботи системи.  
3.4.4 Інтерфейс вебзастосун ку за обраною темою.  
3.4.5 Висновки, що містять відповіді на контрольні запитання, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  
 
3.5 Контрольні запитання  
 
3.5.1 Які ергономічні показники інтерфейсу можна виділити?  
3.5.2 Які існують методи кількісного аналізу інтерфейсу?  
3.5.3 Що дозволяє передбачити модель GOMS?  
3.5.4 Які жести розрізняє модель GOMS?  
3.5.5 Що визначає закон Фіттса?  
3.5.6 Що визначає закон Хіка?  
3.5.7  Поясніть різницю між вайрфрейм, прототип та мокап?  
3.5.8  Яке програмне забезпечення використовують для розробки 
вайрфреймів, прототипів та мокапів?  
  
45 
 
4 ЛАБОРАТОРНА РОБОТА №  4  
АНАЛІЗ ТА ПРОЄКТ УВАННЯ АРХІТЕКТУРИ 
ВЕБ ЗАСТОСУНКІВ  НА ОСНОВІ ПРЕДМЕТНОЇ  
ОБЛАСТІ  
 
4.1 Мета роботи  
 
Навчитися розробляти та проводити аналіз архітектури вебза с-
тосун ків на основі предметної області . 
Навчитися розробляти архітектуру вебзастосун ків з викори с-
танням фреймворків та CMS, провести порівняльний аналіз архітектур 
вебзастосун ків, розроблених на основі предметної області та за вик о-
ристання фреймворків або CMS  
 
4.2 Короткі теоретичні відомості  
 
Архітек тур програмного забезпечення існує досить багато. К о-
жна з них має як плюси так і недоліки. Більш того, серед різноманіття 
є схожі представники. На сьогоднішній день найчастіше використ о-
вуються: Model -view -controller (MVC), Model -view -presenter (MVP), 
Model -View -View Model (MVVM).  
 
4.2.1 Схема проєкт ування MVC  – Model -View -Controller  
 
MVC – це фундаментальний патерн, який знайшов застосування 
в багатьох технологіях.  
Спільна риса для усіх патернів – відокремлення інтерфейсу к о-
ристувача (UI) від логіки програмуван ня, що дозволяє дизайнерам р о-
бити свою роботу, не замислюючись про к од програми. Так само н а-
дається можливість виділення моделі даних, що дає розробникам м о-
жливість створення модульних тестів.  
MVC складається з трьох компонент: View (подання, предста в-
лення, інтерфейс), Model (модель, бізнес логіка) і Controller (контр о-
лер, містить логіку на зміну моделі при певних діях користувача). О с-
новна ідея цього патерну в тому, що і контролер і представлення з а-
лежать від моделі, але модель ніяк не залежить від ци х двох комп о-
46 
 
нент. Це як раз і дозволяє розробляти і тестувати модель, нічого не 
знаючи про подання і контролери . 
В ідеалі контролер так само нічого не повинен знати про пред-
ставлення  (хоча на практиці це не завжди так), і в ідеалі для одного 
представлення  можна перемикати контролери, а так само один і той 
же контролер можна використовувати для різних представлень  (так, 
наприклад, контролер може залежати від користувача, який увійшов в 
систему). Користувач бачить представлення , на ньому ж робить якісь 
дії, ц і дії представлення  перенаправляє контролеру та «підписується » 
на зміну даних моделі.  
Контролер у свою чергу проводить  певні операції  над моделлю 
даних, представлення  отримує останній стан моделі і відображає її 
користувачеві. Архітектура MVC представлена рис. 4.1.  
 
 
Рисунок 4.1 – Архітектура MVC  
 
4.2.2 Архітектура MVP  – Model -View -Presenter  
 
Даний патерн також  складається з трьох компонент. Тільки п о-
дивившись на наведену схему  його архітектури (рис. 4.2)  стає ясно, 
Model
(Модель)Model
(Модель)View
(Представлення)View
(Представлення)
Controller
(Контролер) Controller
(Контролер) Дії
користувача
Передача
виклику
Зміна
моделіПовідомлення 
про зміни
47 
 
що представленню  немає потреби підписуватися на зміни моделі, т е-
пер контролер, перейменований в Presenter (представник)  дає знати 
представленням  про зміни. Даний підхід дозволяє створювати абстр а-
кцію представлення . Реалізувати даний патерн можна за допомогою 
винесення інт ерфейсів представлення . У кожного представлення  бу-
дуть інтерфейси з певними наборами методів і властивостей, що необ-
хідні представнику . 
 
Рисунок 4.2 – Архітектура MVP  
 
Представник  в свою чергу ініціалізується з даним інтерфейсом, 
підписується на події подання та за необхідності відсилає дані. Даний 
підхід дозволяє розробляти додатки з використанням методології TDD 
(Test -driven development).  
Model
(Модель)Model
(Модель)View
(Представлення)View
(Представлення)
Presenter
(Презентер) Presenter
(Презентер) Дії
користувача
Передача
виклику
Зміна
моделіПовідомлення 
про зміниОновлення
48 
 
4.2.3 Архітектура MVVM  – Model -View -ViewModel  
 
У цій архітектурі знову присутні три компоненти: модель, пре д-
ставлення та третій компонент – додаткова модель під назвою 
ViewModel. Даний патерн підходить до таких технологій, де присутня 
двостороння синхронізація (біндінг) елементів управління на мо дель . 
ViewModel – це деякий с упер -конвертер, який перетворює дані моделі 
подання, в ньому описуються основні властивості подання, а також 
логіка взаємодії з моделлю.  Архітектура MVVM представлена на 
рис. 4.3. 
 
Рисунок 4.3 – Архітектура MVVM  
Model
(Модель)Model
(Модель)View
(Представлення)View
(Представлення)
View Model View ModelДії
користувача
Передача
виклику
Зміна
моделіПовідомлення 
про зміниОновлення
Отримання 
данихДані
49 
 
Загалом MVC, MVP, MV VM – це схем и використання декількох 
шаблонів проєкт ування, за допомогою яких модель даних програми, 
користува цький інтерфейс і взаємодія з користувачем роз ділені на три 
окремих компоненти . 
Логіка відображення  (front end, frontend) – відповідає за збір 
даних від користувачів в різних формах  та обробку їх у відповідності 
зі специфікацією.  
Логіка управління даними  (back -end, backend) – обробляє дані, 
отримані від користувача для передачі на наступний рівень.  
Бізнес -логіка  – сукупність правил, принципів, залежностей п о-
ведінки об'єктів предметної області. Це реалізація предметної області 
в інформаційній системі.  
Особливості розробки архітектури вебзастосун ку на основі 
предметної області : 
– можливість більш докладного опису лог іки взаємодії об’єктів 
предметної області;  
– можливість гнучкої зміни логіки роботи додатку;  
– відсутність надлишкового коду в кінцевій реалізації;  
– поділ логіки відображення, логіки управління даними і бізнес -
логіки.  
Недоліки розробки архітектури вебзастосун ку на основі предм е-
тної області:  
– велика трудомісткість при створенні проєкт у; 
– більш жорсткі вимоги до кваліфікації розробника.  
 
4.2.4 Фреймворки  
 
Фреймворк (англ. framework) – у веб -програмуванні це спеці а-
льна програмна платформа або комплекс компонентів і моделей, що 
полегшують процес веб -розробки. Хоча фреймворки відомі і в інших 
областях програмування, саме в веб-розробці в останні роки вони на-
були інтенсивного розвитку.  
Зараз існують найрізноманітніші ф реймворки, створені за доп о-
могою таких мов програмування, як Java, PHP, Ruby і деяких інших. 
Особливо популярні проєкт и для Java і PHP. Для найбільш затребув а-
них фреймворків створюються спільноти, розробляються підручники 
та документація.  
 
50 
 
4.2.4.1  Фреймворк Larave l 
 
Laravel – безкоштовний веб -фреймворк з відкритим кодом, пр и-
значений для розробки з використанням архітектурної моделі MVC. 
Laravel випущений під ліцензією MIT. Сирцевий код проєкт у розм і-
щується на GitHub.  
 
 
Рисунок 4.4 – Головна сторінка проєкт у Larave l 
 
Ключові особливості, що лежать в основі архітектури Laravel:  
– пакети (англ. packages) – дозволяють створювати і підключати 
модулі у форматі Composer до додатка на Laravel. Багато додаткових 
можливостей вже доступні у вигляді таких модулів;  
– Eloquent O RM – реалізація шаблону проєкт ування 
ActiveRecord на PHP. Дозволяє строго визначити відносини між об'є к-
тами бази даних;  
– логіка застосування – частина застосування, що розробляється, 
оголошена або за допомогою контролерів, або маршрутів (функцій -
замикань) ; 
– зворотна маршрутизація пов'язує між собою згенеровані за-
стосуванням посилання і маршрути, дозволяючи змінювати останні з 
автоматичним оновленням пов'язаних посилань. При створенні пос и-
лань за допомогою іменованих маршрутів Laravel автоматично ген е-
рує к інцеві URL;  

51 
 
– REST -контролери – додатковий шар для поділу логіки обро б-
ки GET - та POST -запитів HTTP.  
– автозавантаження класів – механізм автоматичного завант а-
ження класів PHP без необхідності підключати файли їх визначень в 
include . Завантаження на вимогу запобігає завантаженню непотрібних 
компонентів; завантажуються тільки ті з них, які дійсно використов у-
ються;  
– укладачі представлень  (англ. view composers) — блоки коду, 
які виконуються при генерації представлення;  
– інверсія управління – дозволяє отримува ти екземпляри об'є к-
тів за принципом зворотного управління. Також може використовув а-
тися для створення та отримання об'є ктів-одинаків (англ. singleton);  
– міграції – система управління версіями для баз даних  (БД) . 
Дозволяє зв'язувати зміни в коді програми зі змінами, які потрібно 
внести в структуру БД, що спрощує розгортання і оновлення прогр а-
ми; 
– модульне тестування (юніт -тести) – відіграє дуже велику роль 
в Laravel, який сам по собі містить велику кількість тестів для запоб і-
гання регресій (помилок внаслі док оновлення коду або виправ лення 
інших помилок);  
– посторінков е виведення  (англ. pagination) – спрощує генерацію 
сторінок, замінюючи різні способи вирішення цього завдання єдиним 
механізмом, вбудованим в Laravel.  
Структура застосунку, що розробляється з використанням 
Laravel продемонстрована на рис. 4.5.  
Структура Laravel проста і зрозуміла. Коренева директорія мі с-
тить різні папки і файли:  
– app – ця папка містить основний код програми;  
– bootstrap – скрипт початк ового завантаження програми;  
– config – ця папка містить файли конфігурації програми;  
– database – ця папка містить перенесену базу даних;  
– public – це коренева папка документа програми. З неї запуск а-
ється додаток Laravel. Вона також містить ресурси прогр ами, такі як 
JavaScript, CSS, зображення, тощо;  
– resources – ця папка містить вихідні ресурси, такі як файли 
LESS та Sass, файли локалізації та мов і шаблони, які відображаються 
як HTML;  
52 
 
– storage – ця папка містить сховище застосунку, наприклад, з а-
вантаж ені файли, тощо. Сховище для платформи (кеш) і журнали, 
створені за стосунком;  
– test - ця папка містить різні тестові приклади;  
– vendor – ця папка містить залежності Composer.  
 
 
Рисуно к 4.5  – Структура застосунку, що розробляється з використа н-
ням Larave l 
 
App Directory – це каталог програми. Він містить інші додаткові 
папки , а саме:  
– Console – всі команди м айстра зберігаються в цій папці;  
– Events – у цій папці зберігаються події, які підтримує застос у-
нок. Події можуть використовуватися для оповіщення і нших частин 

53 
 
програми про те, що відбулася певна дія, що забезпечує розробникам 
велику гнучкість;  
– Exceptions – ця папка містить обробник винятків програми, і в 
ній також можна зберігати будь -які винятки, створювані додат ком;  
– Http – ця папка містит ь конт ролери, фільтри та запити;  
– Jobs – ця папка містить завдання для застосунку ; 
– Listeners – ця папка містить класи обробників подій. Обробн и-
ки приймають подію і виконують логіку відповідно до цього. Напр и-
клад, подія UserRegistered може оброблят ися обробник ом 
SendWelcomeEmail;  
– Policies – ця папка містить різні політики, які можна встанов и-
ти для програми;  
– Providers – ця папка містить провайдери служб.  
 
4.2.4.2  Фреймворк Yii2  
 
YesItIs (Yii) – це високопродуктивний компонентний PHP 
фреймворк, призначений для швидкої розробки вебзастосун ків. Yii – 
це універсальний фреймворк і може бути задіяний у всіх типах вебза с-
тосун ків. Завдяки його компонентній структурі та відмінній підтримці 
кешування, фреймворк особливо підходить для розробки таких вел и-
ких проєкт ів, як портали, форуми, CMS, магазини або RESTful -
додатки.  
 
 
Рисунок 4.6  – Головна сторінка проєкт у Yii Framework  
 

54 
 
Якщо порівняти Yii з іншими популярними фреймворками, м о-
жна відмітити:  
– як і багато інших PHP фреймворків , для організації коду Yii 
викори стовує архітектурний шаблон MVC;  
– Yii дотримується філософії простого і елегантного коду, не 
намагаючись ускладнювати дизайн тільки заради проходження б удь-
яким шаблонами проєкт ування;  
– Yii є full -stack фреймворком і включає в себе перевірені і до б-
ре зарекомендували себе можливості, такі як ActiveRecord для рел я-
ційних і NoSQL баз даних, підтримку REST API, багаторівневе кеш у-
вання та інші;  
– Yii відмінно розшир юється . Можна налаштувати аб о замінити 
практично будь -яку частину основного коду.  
Yii підтримується і розвивається сильною командою і великою 
спільнотою розробників . Автори фреймворку стежать за тенденціями 
веб-розробки і розвитком інших проєкт ів. Найбільш підходящі мо ж-
ливості і кра щі практики регулярно впроваджуються в фреймворк у 
вигляді простих і елегантних інтерфейсів . 
Структура застосунку, що розробляється за допомогою Yii пр о-
демонстровано на рис. 4.7 . 
 
 
Рисунок 4.7  – Структурна схема Yii -застосунку  

55 
 
Структура найпростішого дода тку на Yii буде наступною:  
– assets – файли ресурсів;  
– css – каскадні таблиці стилів;  
– framework – коди фреймворку Yii;  
– image – зображення;  
– protected – функціональна частина сайту;  
– themes – теми оформлення Yii;  
– index -test.php – тестовий вхідний  файл, для опробування рі з-
номанітних функцій;  
– index.php – вхідний скрипт будь -якого проєкт у на Yii, саме цей 
файл запускає роботу фреймворку.  
У protected знаходяться 4 найважливіші складові:  
– config – через цей файл можна налаштувати роботу сайту за 
потребами людини, тобто підключити якісь модулі, базу даних, GII, 
тощо;  
– controllers – класи, які управляють логікою сайту;  
– models – моделі, які визначають привила роботи із базою (то б-
то, майже із усією інформацією на сайті);  
– views – файли відображен ня даних кінцевому користувачеві.  
Основна схема роботи Yii така: при вході користувача на сайт 
(заповненні форми, перехід на іншу сторінку і т. д.) починає працюв а-
ти контролер (який контролер починає працювати , залежить від дій 
користувача), який в свою ч ергу починає використовувати моделі 
(якщо потрібно отримати якісь дані з бази даних або навпаки записати 
туди) і представлення (якщо користувачеві необхідно надати резул ь-
тати роботи контролера).  
Контролери складаються з подій (action), які можуть виконуват и 
різні дії. Всі ці події починаються зі слова action і закінчуються при с-
тавкою, наприклад Index. У найпростішому випадку контролер скл а-
дається з таких подій (action):  
– actionIndex – подія запускається за замовчуванням при перш о-
му зверненні до контролера;  
– actionError – подія описує роботу сайту при появі помилки;  
– actionContact – подія описує роботу з контактною формою;  
– actionLogin – подія авторизації користувача на сайті;  
– actionLogout – подія виходу користувача з особистого кабін е-
ту. 
56 
 
Представлення зберігаються в папці views, і кожне з них відп о-
відає своєму контролеру.  
 
4.2.5 Системи управління вмістом  
 
CMS (Content Management System – система управління вмі с-
том) – програмний комплекс, що надає функції створення, редагува н-
ня, контролю та організації структ ури вебзастосун ку (сайту), а також 
текстової та графічної інформації (вмісту).  
Переваги використання CMS при розробці:  
– протестований і перевірений багатьма розробниками код;  
– універсальність;  
– простота використання.  
Недоліки використання CMS при розробці:  
– обмеження предметної області тими об'єктами, які передбач е-
ні в CMS;  
– визначення основної логіки роботи програми розробниками 
CMS. Внесення змін в логіку проблематично;  
– зайва універсальність і надлишковий функціонал.  
CMS поділяються на ECMS ( Enterprise Content Management 
System – система управління вмістом масштабу підприємства) та 
WCMS (Web Content Management System – система управління веб -
вмістом).  
WCMS складається з клієнтської та серверної частин.  
Клієнтська частина – веб-сайт, доступний для відвідувачів та з а-
реєстрованих користувачів.  
Серверна частина містить шар адміністрування веб -сайту, з 
яким взаємодіє адміністратор, де виконується конфігурація, обслуг о-
вування, очищення, генерація статистики та створення нового конте н-
ту. 
Wordpress, Jo omla та Drupal є прикладами безкоштовних CMS.  
WordPress дозволяє створювати сайти різних типів, інформаці й-
ні, новинні тощо, але в першу чергу використовується для створення 
блогів або нескладних сайтів інформаційного типу.  
Недоліки WordPress: не досить шви дка робота сайту, можл и-
вість збоїв у випадку високої відвідуваності.  
57 
 
Joomla має більш широку галузь застосування порівняно з 
Wordpress і загалом є універсальною. Не позбавлена проблем зі шви д-
кістю роботи за високої відвідуваності.  
Drupal може використовува тись для створення форумів, блогів, 
онлайн -енциклопедій, сайтів спільнот. Проте є менш універсальною 
порівняно з Joomla. До недоліків відносять слабке використання 
об’єктних можливостей PHP та відсутність зворотної сумісності API.  
Magento – система управлі ння інтернет -магазинами. Magento – 
це досить молодий движок. Движок побудований на ZendFramework, 
що відразу визначає його обсяг: Він великий і важкий, але й досить 
потужний. На відміну від Joomla, де прямо в адміністративній частині 
можна призначити місце  відображення і параметри конкретного м о-
дуля на сторінці, Magento в основному націлена на редагування е к-
ранних блоків вітрини не через адміністративну частину, а через фа й-
ли логічної розмітки і файли шаблонів.  
OpenCart — система керування вмістом з відкрит им кодом, пр и-
значена для створення інтернет -магазинів. Розповсюджується за ліц е-
нзією GNU General Public License. OpenCart може бути встановлено на 
будь який веб -сервер Apache з підтримкою PHP5 і MySQL. Навколо 
OpenCart сформувалася велика спільнота, завдяк и якій створено понад 
8500 безкоштовних розширень у вигляді додаткових модулів. Найв а-
гомішими перевагами OpenCart над системами Magento, Virtuemart і 
osCommerce є сучасна MVC -архітектура, підвищена швидкість роб о-
ти, vQmod, багатофункціональна адміністратив на панель управління 
контентом та менше споживання серверних ресурсів. OpenCart добре 
зарекомендував себе в комерційному секторі як надійна і недорога в 
обслуговуванні система електронної торгівлі, з підтримкою розраху н-
ку всіма найвідомішими системами елек тронної оплати.  
PrestaShop – CMS для інтернет -магазинів з відкритим кодом. 
Система написана на PHP, для написання шаблонів використовується 
Smarty, для створення баз даних використовується MySQL. Система 
призначена для малого та середнього бізнесу і має бі льше 310 станд а-
ртних функцій для швидкого створення функціонального магазину , 
підтримує величезну кількість модулів і плагінів  без додаткових н а-
лаштувань.  
Для роботи сайту та його просування фреймворки, можливо, 
будуть навіть ефективніше, ніж системи управ ління сайтом. На відм і-
ну від останніх, фреймворки забезпечують сайтам швидкодію і не в и-
58 
 
магають багато ресурсів. Втім, CMS, по суті, теж є фреймворком, а 
точніше, більш модернізованим фреймворком, в той  час як, напр и-
клад, Laravel  або Yii вважаються чистими фреймворками. Рішення що 
використовувати для розробки сайту: фреймворк  або CMS – прийм а-
ється під час проєкт ування та залежить від:  мети, конкрет ного  завда н-
ня, складності проєкт у, ресурсів та кінцевого користувача.  
 
4.3 Завдання на лабораторну роботу  
 
4.3.1 Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
4.3.2 Проаналізувати предметну область.  
4.3.3 Розробити архітектуру вебзастосун ку на основі предметної 
області.  
4.3.4  Обрати фреймворк  для розроблення вебзастос унку .  
4.3.5  Ознайомитись  з архітектурою обраного фреймворку.  
4.3.6  Розробити архітектуру вебзастосун ку на основі викори с-
тання обраного фреймворку.  
4.3.7  Порівняти архітектуру вебзастосун ку, розроблену з вик о-
ристанням фреймворку, з архітектурою, розробленою на основі пре д-
метної області. Визначити, який варіант розроблення архітектури є 
більш ефективним для обраної теми проєкт ування.  
4.3.8 О формити звіт з роботи.  
4.3.9  Відповісти на контрольні питання.  
 
4.4 Зміст звіту  
 
4.4.1 Тема та мета роботи.  
4.4.2 Тема, обрана для проєкт ування.  
4.4.4 Схематичне зобр аження архітектури вебзастос унку  на о с-
нові предметної області.  
4.4.5 Схематичне зображення архітектури вебзастос унку  (на ос-
нові фреймворку або CMS ). 
4.4.6 Обґрунтування вибору архітектури вебзастос унку.  
4.4.7 Висновки, що мі стять відповіді на контрольні запитання, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  
 
59 
 
4.5 Контрольні запитання  
 
4.5.1 Наведіть особливості архітектури MVC.  
4.5.2  Наведіть особливості архітектури MVP.  
4.5.3  Наведіть особливості архі тектури MVVM.  
4.5.4  Які недоліки несе в собі проєкт ування вебзастос унків на 
основі предметної області?  
4.5.5 Наведіть узагальнену схему вебзастос унку на основі пр ед-
метної області.  
4.5.6 Що таке frontend -частина вебзастос унку ? 
4.5.7 Що таке backend -частина вебзастос унку ?  
4.5.8 Що таке бізнес -логіка?  
4.5.9  Наведіть узагальнену схему веб - застосунку  на основі 
Laravel.  
4.5.10  Наведіть узагальнену схему вебзастос унку  на основі Yii.  
4.5.11  Як відрізняється структура застосунку в Yii та Laravel?  
4.5.12 Які переваги  та недоліки  має проєкт ування вебзастос унків  
на основі CMS порівняно з проєкт уванням на основі пр едметної обл а-
сті? 
4.5.13 Наведіть узагальнену схему вебзастос унку  на основі 
CMS.  
4.5.14 За якого варіанту побудови архітектури зв’язність  між 
компонентами вебзастос унку  є вищою?  
4.5.15 Які функціональні можливості надають системи керува н-
ня вмістом?  
 
 
 
60 
 
5 ЛАБОРАТОРНА РОБОТА № 5 
ПРОГРАМНА  РЕАЛІЗА ЦІЯ РОЗРОБЛЕНОЇ 
АРХІТЕКТУРИ ВЕБ ЗАСТОСУНКУ  
 
5.1  Мета роботи  
 
Навчитися використовувати середовища розробки для роботи з 
мовою програмування PHP . 
Навчитися використовувати пакетний менеджер Composer для 
встановлення та роботи із сучасними фреймворками.  
 
5.2 Короткі теоретичні відомості  
 
5.2.1 Менеджер пакетів Composer  
 
При створенні вебзастос унку з використанням PHP використ о-
вуються поняття пакету  та репозиторію . 
Пакет – власне, та сама бібліотека, яка створюється або викор и-
стовується в проєкт і, як залежність.  
Репозиторій (Registry) – сховище пакетів PHP, яке називається 
Packagist. Коже н бажаючий може опублікувати пакет в Packagist, в и-
тративши буквально хвилину часу, а інші зможуть його використов у-
вати. Пакети в PHP ніяк не пов'язані з Git і GitHub.  
Для вирішення проблем з повторним використанням та упра в-
лінням пакетами використовуються менеджери пакетів.  
Composer – менеджер пакетів прикладного рівня для мови пр о-
грамування PHP, що забезпечує стандартний формат для управління 
залежностями у програмному забезпеченні та необхідними бібліот е-
ками.  
Composer працює з командного рядка і встановлю є залежності 
(наприклад, бібліотек) для застосунку. Він також дозволяє користув а-
чам встановлювати PHP пакети, доступні на ресурсі «Packagist», який 
є його основним сховищем, що містить доступні пакети. Він також 
реалізує автозавантажувач класів, для встано влених бібліотек і це п о-
легшує використання коду від сторонніх розробників.  
Composer використовується як складова частина декількох п о-
пулярних PHP проєкт ів з відкритим вихідним кодом, серед яких є б і-
61 
 
льшість популярних фреймворків: Symfony, CodeIgniter, Cak ePHP, 
FuelPHP та , звісно  ж, Laravel й Yii. Серед CMS Composer використ о-
вує Drupal починаючи з 8 -ої версії.  
 
5.2.2 Середовища розробки  
 
При роботі з PHP у якості середовища розробки можна викори с-
товувати навіть звичайний «Блокнот» від компанії Microsoft, проте це 
буде вкрай не зручно та мало результативно.  
Серед середовищ розробки при роботі із PHP можна виділити 
декілька вдалих рішень, що поширюються із вільною ліцензією.  
NetBeans IDE – вільне ін тегроване середовище розробки. Сер е-
довище підтримує велику кількість мов програмування, серед яких: 
Java, JavaFX, C/C++, PHP, JavaScript, HTML5, Python, Groovy. Серед о-
вище може бути встановлене як для підтримки окремих мов , так у по-
вній конфігурації.  
NetBe ans IDE доступна для платформ Microsoft Windows, 
GNU/Linux, FreeBSD, і Solaris (як SPARC, так x86). За якістю і мо ж-
ливостям останні версії NetBeans IDE змагаються з найкращими інте г-
рованими середовищами розробки, підтримуючи рефакторинг, проф і-
лювання, виді лення синтаксичних конструкцій кольором, автодопо в-
нення мовних конструкцій на льоту, шаблони коду та інше.  
 
 
Рисунок 5.1 – Середовище розробки NetBeans  
 

62 
 
Eclipse PHP Development Tools – інтегроване середовище розр о-
бки застосунків на мові програмування PHP, розроблене на основі 
Eclipse, поширюване на умовах ліцензії Eclipse Public License.  Серед 
особливостей можна виділити:  
– згортання коду;  
– рефакторинг;  
– генерація коду (методи доступу до членів класу, майстер кл а-
сів та інтерфейсів)  
– аналіз та виправлення коду;  
– підтримка PHP 4 і PHP 5 (включаючи замикання і простору 
імен);  
– ієрархічне представлення класів і методів  
– налагодження PHP -скриптів (як локально, так і за допомогою 
інтеграції з Zend Server і XDebug);  
– підтримка HTML, CSS, JavaScript.  
 
 
Рисунок 5.2 – Середовище розробки Eclipse PHP Development Tools  
 
Atom – розроблений компанією «GitHub» вільний текстовий р е-
дактор і редактор коду, який може використовуватися як самодостатнє 
рішення, так і у ролі техно логічного стека для побудови різних спец і-
алізованих рішень. Atom надає засоби крос -платформового редаг у-
вання коду, включає вбудований пакетний менеджер і інтерфейс нав і-
гації файловою системою, надає засоби для одночасної спільної роб о-
ти з кодом, має інтеле ктуальну систему автодоповнення вводу, надає 

63 
 
режими сумісності з Vim і Emacs, підтримує API для розробки розш и-
рень. Кілька файлів можуть бути відкриті в різних вкладках і одноча с-
но відображені з використанням вертикального або горизонтального 
розбиття пане лей. Інтерфейс може налаштовуватися через теми офо р-
млення, підтримуються вкладки, закладки, розумний контекстний п о-
шук коду, схлопування блоків коду, одночасне використання декіл ь-
кох курсорів і областей виділення, наочна позначка змін, автодопо в-
нення та пе ревірка коду для різних мов (Ruby, Python, SQL, PHP, Perl, 
Objective -C, C/C++, JavaScript, Java, Go тощо).  
Для безпроблемної роботи з PHP рекомендується підключити 
пакети: Script, Language php, Linter php та Php Twig.  
 
 
Рисунок 5.3 – Середовище розробки Atom  
 
5.3 Завдання на лабораторну роботу  
 
5.3.1  Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
5.3.2 Встановити менеджер пакетів Composer.  
5.3.3 Використовуючи Composer встановити обраний фрей м-
ворк.  
5.3.4 Розробити структуру вебзастос унку на основі викори стан-
ня обраного фреймворку (або на основі предметної області, якщо о б-
рано такий варіант побудови архітектури).  
5.3.5 Розробити та підключити БД до вебзастос унку.  

64 
 
5.3.6 Розробити основні (або статичні) сторінки вебзастос унку.  
5.3.7 Оформити звіт з роботи.  
5.3.8 Відповісти на контрольні питання.  
 
5.4 Зміст звіту  
 
5.4.1  Тема та мета роботи.  
5.4.2  Тема, обрана для проєкт ування.  
5.4.3  Структура вебзастос унку, що реалізує систему.  
5.4.4 Модель розробленої БД для вебзастос унку.  
5.4.5 Скрінш оти та сирцевий код розроблених веб -сторінок.  
5.4.6 Висновки, що містять відповіді на контрольні запитання, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  
 
 
5.5 Контрольні запитання  
 
5.5.1  Поясніть поняття пакет у при розробці застосунку з вик о-
ристанням PHP.  
5.5.2  Поясніть поняття репозиторі ю при розробці застосунку з 
використанням PHP.  
5.5.3  Що таке менеджер пакетів?  
5.5.4 У чому полягає ідея використання менеджеру пакетів?  
5.5.5 Які середовища розробки зазвичай використовуютьс я при 
розробці з використанням PHP?  
 
 
 
 
 
 
 
65 
 
6 ЛАБОРАТОРНА РОБОТА №  6 
РОБОТА ІЗ СИСТЕМАМИ К ЕРУВАННЯ 
ВЕРСІЯМИ. РОЗГОРТАННЯ РЕПОЗИТОР ІЮ 
 
6.1 Мета роботи  
 
Навчитися використовувати системи керування версіями та ро з-
гортати репозиторі й для роботи над веб застосунком гр упи розробн и-
ків. 
 
6.2 Короткі теоретичні відомості  
 
Система керування версіями  (англ. Version Control System або 
Revision Control System) – це ПЗ для полегшення роботи зі змінною 
інформацією. Система управління версіями дозволяє зберігати кілька 
версій одного і того ж документа, при необхідності повертатися до 
більш ранніх версій, визначати, хто і коли вносив правки та зміни , та 
багато іншого.  
Такі системи найбільш широко використовуються при розробці 
ПЗ для зберігання вихідних кодів розроблюваної п рограми. Однак в о-
ни можуть з успіхом застосовуватися і в інших областях, в яких в е-
деться робота з великою кількістю електронних документів , які безп е-
рервно змінюються . Зокрема, системи управління версіями застос о-
вуються в системах автоматизованого проєкт ування , зазвичай в складі 
систем управління даними про виріб. Управління версіями використ о-
вується в інструментах конфігураційного управління.  
Кожна система управління версіями має свої специфічні осо б-
ливості в наборі команд, порядку роботи користувачів та а дміністр у-
ванні. Тим не менш, загальний порядок роботи для більшості систем 
керування версіями абсолютно стереотипний. Тут передбачається, що 
проєкт , яким би він не був, вже існує, а на сервері розміщений його 
репозиторій, до якого розробник отримує доступ.  
Тож загальній порядок роботи можна поділити на наступні ет а-
пи: 
1) початок роботи з проєкт ом; 
2) щоденний цикл роботи;  
а) оновлення робочої копії;  
66 
 
б) модифікація проєкт у; 
в) фіксація змін.  
Git – розподілена система керування версіями файлів та спільної 
роботи. Проєкт  було створено для управління розробкою ядра Linux. 
Git є однією з найефективніших, надійних і високопродуктивних си с-
тем керування версіями, що надає гнучкі засоби нелінійної розробки, 
що базуються на відгалуженні і злитті гілок. Для забезпечення цілі с-
ност і історії та стійкості до змін заднім числом використовуються 
криптографічні методи, також можлива прив'язка цифрових підписів 
розробників до тегів і комітів.  
Система с проєкт ована як набір програм, спеціально розробл е-
них з врахуванням їхнього використання у скриптах. Це дозволяє зр у-
чно створювати спеціалізовані системи управління версіями на базі 
Git або користувацькі інтерфейси. Система має ряд користувацьких 
інтерфейсів: наприклад, gitk та git -gui розповсюджуються з самим Git.  
Серед основних переваг розго ртання репозиторію з використа н-
ням Git можна виділити  наступні : 
– при завантаженн і нових версій  з віддаленої копії автоматично 
оновлюється  live-копія сайту;  
– виправлення файлів на сервері не будуть руйнувати історію 
оновлення версій ; 
– простота, не потрібні особливі правила виконання оновлення 
версій ; 
– можна застосувати до вже запущеного сайту, без повторного 
розгортання  або переміщення файлів.  
Слід відзначити, що механізм розгортання Git репозиторію на 
локальному комп’ютері (за умови  використання його у якості локал ь-
ного серверу) та на сервері значно різняться. У випадку використання 
локального серверу вам не потрібен веб -сервер для Git. Ви можете 
створити сховище Git на локальній машині та клонувати його на тому 
ж комп'ютері.  
Основні  кроки для розгортання репозиторію на локальній м а-
шині мають наступний вигляд.  
mkdir /c/GIT  
cd /c/GIT/  
git init --bare myproject.git  
 
cd /c/UserWebServer /www/myproject/  
67 
 
git init  
git add .  
git commit -m "first commit"  
git remote add origin /c/GIT/myproject.git  
git push -u origin master  
Тепер можна почати роботу над проєкт ом в папці  
C:\UserWebServer \www\myproject \. 
Щоб створити і переключитися на використання нової гілки,  
git checkout -b new_branch . 
 
6.2.1 Онлайн -репозиторії  
 
Для більш зручної ком андної роботи над проєкт ами найчастіше 
використовують дистанційні або онлайн репозиторії. Найбільш поп у-
лярні серед таких: GitHub, GitLab, Bitbucket. В цьому випадку можна 
вважати, що Git – це технологія – репозиторій коду, а онлайн -
репозиторій – сервер яки й надає цю технологію.  
Github – потужна, безпечна і найпопулярніша онлайн платформа 
для розміщення проєкт ів з контролем версій  з використанням Git. Хоч 
Github більше відомий як платформа для розробки open source проє к-
тів, ресурс також підтримує можливість використання приватних р е-
позиторіїв.  Окрім розміщення коду  учасники можуть спілкуватися та 
коментувати правки один одного. За допомогою широких можливо с-
тей Git програмісти можуть об'єднувати свої репозиторії – GitHub 
пропонує зручний інтерфейс для цього і може відображати внесок к о-
жного учасника у вигляді дерева. Прямо на сайті можна переглянути 
файли проєкт ів з підсвічуванням синтаксису для більшості мов пр о-
грамування. Можна створювати приватні сховища, які будуть досту п-
ні лише розробнику та  обраним вами людям. Є можливість прямого 
додавання нових файлів в свій репозиторій через веб -інтерфейс серв і-
су. 
68 
 
 
Рисунок 6.1 – Сервіс GitHub  
 
GitLab – відкритий, потужний, безпечний, ефективний, наді й-
ний, наповнений різним функціоналом сервіс для розробки ПЗ на рі з-
них етапах життєвого циклу. Мабуть, це краща альтернатива Github. 
Платформа підтримує облік робочого часу, надає потужні інструменти 
для розгалуження, можливість захистити гілки і теги, функції блок у-
вання файлів, об'єднання запитів, персоналізації повідомлень , ств о-
рення дорожніх карт проєкт ів, виставлення пріоритетів тікетам , ств о-
рення конфіденційних і пов'язаних тікетів, графіка виконання робіт за 
проєкт ами. Крім цього, розробник може створювати тікети з листів і 
переглядати свої зміни за допомогою програм перевірки. GitLab також 
надає можливість використовувати Web IDE і дає доступ до числе н-
них шаблонів проєкт ів для того, щоб легше було почати роботу над 
проєкт ом, а також багато іншого. Використовуючи модуль імпорту, 
можна імпортувати репозиторії з GitHub в  GitLab або на власний се р-
вер GitLab.  

69 
 
 
Рисунок 6.2 – Сервіс GitLab  
 
Bitbucket – це потужна, повністю масштабована і високопроду к-
тивна платформа для розробників, призначена спеціально для проф е-
сійних команд. Початківці та команди, які працюють над проєкт ами з 
відкритим вихідним кодом безкоштовно отримують доступ до аккау н-
ту Bitbucket і до багатьох його функцій. Bitbucket дозволяє легко і м-
портувати репозиторії з Github всього лише за 6 простих кроків, а т а-
кож підтримує сторонні інтеграції. Від конкурентів пл атформу відрі з-
няє наступний функціонал: Bitbucket pipelines, пошук коду, запити на 
включення коду, гнучкі моделі розгортання, порівняння, смарт -
дублювання, відстеження тікетів і списку дозволених IP -адрес, а т а-
кож можливості розгалуження для забезпечення б езпеки робочого 
процесу. Bitbucket пропонує функцію підтримки Git сховища великих 
файлів (LFS) для розробки ігор, що дозволяє створювати необмежену 
кількість приватних репозиторіїв, і легко інтегрувати нову систему у 
вже існуючий робочий процес, а також ма є вбудований модуль для 
безперервних поставок.  

70 
 
 
Рисунок 6.3 – Сервіс Bitbucket  
 
6.3 Завдання на лабораторну роботу  
 
6.3.1 Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
6.3.2  Відправити  (push) першу версію свого проєкт у до репоз и-
торію на GitLab , додавши його як віддалений і відправивши гілку.  
6.3.3  Реалізувати основні функціональні вимоги до системи.  
6.3.4  Відправити (push) до репозиторію зміни (реалізовані фун к-
ціональні вимоги).  
6.3.5 Оформити звіт з роботи.  
6.3.6 Відповісти на кон трольні питання.  
 
6.4 Зміст звіту  
 
6.4.1  Тема та мета роботи.  
6.4.2  Тема, обрана для проєкт ування.  
6.4.3 Скріншоти та сирцевий код розроблених веб -сторінок.  
6.4.4 Скріншоти роботи із Git репозиторієм.   
6.4.5 Висновки, що містять відповіді на контрольні запитан ня, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  

71 
 
6.5 Контрольні запитання  
 
6.5.1  Що таке система керування версіями?  
6.5.2  Які задачі вирішує система керування версіями?  
6.5.3 Назвіть системи керування версіями, окрім Git.  
6.5.4 Поясніть різницю між локальним та дистанційним репоз и-
торієм.   
 
 
  
72 
 
7 ЛАБОРАТОРНА РОБОТА № 7 
РОЗШИРЕННЯ ФУНКЦІОНА ЛЬНОСТІ 
ВЕБ ЗАСТОСУНКІВ  
 
7.1 Мета роботи  
 
Навчитися використовувати модулі розширення функціональн о-
сті для розроблення вебзастосунку.  
 
7.2 Короткі теоретичні відомості  
 
Більшість фреймворків та CMS зроблені за принципом модул ь-
ності: є базова основа (ядро), до якої можливе підключення модулів, 
що надають додаткові функції, яких немає в ядрі фреймворка або 
CMS. Модулі можуть вж е входити до складу комплексу, можуть бути 
встановлені окремо, а також багато систем допускають самостійну 
розробку та включення додаткових модулів. Таким чином, загальний 
функціонал сайту залежить від функцій включених в нього модулів.  
Модулі – це закінче ні програмні блоки, що складаються з мод е-
лей, представлень, контролерів та інших допоміжних компонентів. 
При встановленні модулів в застосунок , кінцевий користувач отримує 
доступ до їх контро лерів . З цієї причини модулі часто розглядаються 
як мініатюрні застосунки .  
 
7.2.1 Приклади розширення функціональності Yii 
 
Віджети – це багаторазові будівельні блоки, використовувані в 
уявленнях для створення складних і параметрів елементів користув а-
льницького інтерфейсу в рамках об'єктно -орієнтованого підходу. Н а-
приклад, в іджет вибору дати (datepicker) дозволяє створювати інтер а-
ктивний інтерфейс для вибору дат, надаючи користувачам програми 
зручний спосіб для введення даних такого типу.  
В комплект Yii входить велика кількість віджетів, наприклад: 
active form, menu, віджети jQuery UI, віджети Twitter Bootstrap. Для 
отримання відомостей щодо використання конкретного віджета, слід 
звернутися до документації відповідного класу.  
73 
 
Для встановлення віджету, слід перейти до Composer та ввести 
наступну команду:  
composer require адреса _віджету  
Приклад встановлення віджету наведено на рис. 7.1.  
 
 
Рисунок 7.1 – Встановлення віджету  
 
Далі потрібно підключити потрібний віджет:  
use yii\widgets\ActiveForm;  
Прикладом використання такого віджету може стати форма для 
заповнення на сторінці зворотного  зв’язку (рис. 7.2) або на сторінці 
авторизації (рис. 7.3).  
 
 
Рисунок 7.2 – Сторінка зворотного  зв’язку  

74 
 
 
Рисунок 7.3 – Сторінка авторизації  
 
7.2.2 Приклади розширення функціональності Laravel  
 
Пакети (packages) – основний спосіб додавання нового функці о-
налу в Laravel. Пакети можуть бути всім, чим завгодно – від класів для 
зручної роботи з датами зразок Carbon, до цілих бібліотек BDD -
тестування зразок Behat.  
Звичайно, є різні типи пакетів. Деякі пакети автономні, що д о-
зволяє їм працювати в складі б удь-якого PHP -фреймворка, не тільки 
Laravel. Прикладами таких окремих пакетів є Carbon і Behat. Будь -
який з них може бути використаний в Laravel за допомогою простого 
додавання їх до файл у composer.json.  
З іншого боку, деякі пакети розроблені спеціально дл я викори с-
тання в Laravel. Вони можуть містити маршрути, контролери, подання 
та налаштування, спеціально розраховані для поліпшення програми на 
Laravel.  
Всі пакети Larav el поширюються через Packagist та  Composer . 
Composer використовує пакети з репозиторію Packagist. Ви не 
можете просто використовувати GitHub -пакети безпосередньо з 
GitHub.  
У розробників є 2 варіанти : 
 можна використовувати пакет, доступний на Packagist для і н-
теграції з API -інтерфейсом shopify. Щоб додати такий пакет  до проє-
кту Laravel, у пап ці, яка містить файл composer.json, слід використати  
наступну команду:  

75 
 
composer require rocket -code/shopify  
 можна створити свій власний пакет packagist, використову ю-
чи сховище Git. В цьому  випадку спочатку клонується репозиторій, а 
потім створюється свій власний обліковий запис у пакеті.  
 
7.2.3 Приклади розширення функціональності CMS  
 
Нижче наведено декілька прикладів модулів, які можна викор и-
стати для розширення функціональності CMS Drupal, завантаживши з 
репоз иторію на drupal.org:  
 Captcha  – захисний механізм картинок «CAPTCHA» , що в и-
користовується при реєстрації;  
 Ecommerce, Ubercart  – системи електронної комерції;  
 FCKeditor , CKEditor , Tinymce  – візуальні редактори;  
 Gallery  – інтеграція з галереєю зображень Gallery2 ; 
 Project  – ведення проєкт ів, включає багтрекер  і інтеграцію з 
CVS  і Subversion ; 
 SPAM  – блокування спаму ; 
 WebForm  – гнучкий модуль для швидкого проєкт ування і н-
терактивних форм (опитування, зворотній зв'язок).  
Для інсталяц ії модуля в Drupal необхідно виконати наступні 
кроки:  
1) завантажити модуль зі сторінки drupal.org/project/[модуль], 
впевнившись, що версія модуля відповідає версії системи;  
2) розпакувати файли з архіву;  
3) ознайомитись з файлами README.txt  та INSTALL.txt , які мі с-
тять інформацію про можливості модуля, його інсталяцію та налашт у-
вання;  
4) скопіювати папку модуля в системну папку додаткових м о-
дулів sites/all/modules ; 
5) перейти на сторінку  «Управління → Створення сайту → Мо-
дулі» та включити встановлений модуль;  
6) виконати для модуля необхідне налаштування;  
7) перейти на сторінку «Управління → Користувачі → Права  
доступу» та визначити права доступу до модуля.  
Модуль CMS Drupal складається з двох файлів, які мають міст и-
тись у /sites/all/modules : ім’ямодуля.info  та ім’ямодуля.module . Другий 
файл містить код модуля, а перший – інформацію про модуль: ім’я, 
76 
 
опис, версію ядра, які підтримує модуль, а також список модулів, н е-
обхідних для роботи даного модуля, та пакет, до якого відноситься 
модуль.  
Приклади плагінів, які вик ористовуються для розширення фун к-
ціональності ядра CMS Wordpress:  
 WordPress Database Backup  – дає змогу зробити бекап бази 
даних;  
 MobilePress – створює мобільну версію сайту;  
 All in One SEO Pack  – дозволяє виконувати пошукову опт и-
мізацію;  
 Akismet  – допомагає боротися зі спам -коментарями;  
 Simple Tags  – дозволяє працювати з тегами;  
 Related Posts  – дозволяє виводити наприкінці кожної публ і-
кації список схожих статей.  
Для інсталяції плагіну в Wordpress необхідно: завантажити фа й-
ли обраного плагіну і завантажити їх у папку /public_html/wp -
content/plugins /Wordpress. Після цього можливість активації плагіну 
з’явиться у адміністративній частині (пункт меню «Модулі »). Слід 
натисн ути на кнопку «Активувати » та увімкнути плагін.  
Плагін Wordpress складається з файлу (або файлів) PHP, а також 
може додатково містити  файли JavaScript, CSS, зображення тощо.  
На початку файлу PHP необхідно розмістити стандартний інф о-
рмаційний заголовок (назва плагіну, адреса веб -сторінки з описом 
плагіну, короткий опис плагіну, номер версії плагіну, ім’я автора та 
його веб -сторінка) та і нформацію про ліцензію.  
Для розширення функціональності CMS Joomla можна зокрема 
використати наступні модулі:  
 mod_syndicate  – відображає посилання на RSS -стрічку пот о-
чної сторінки;  
 mod_wrapper  – створює у вказаній позиції вікно, в якому в і-
дображається стор інка;  
 mod_poll  – виводить в обрану позицію голосування;  
 mod_latestnews  – виводить список останніх опублікованих 
матеріалів;  
 mod_related_items  – порівнює ключові слова у поточному м а-
теріалі та знаходить у базі даних матеріали з ключовими словами, що 
співпад ають, після чого виводить список схожих матеріалів;  
 mod_stats  – відображає статистику сайту.  
77 
 
Для інсталяції модуля в Joomla необхідно виконати наступні 
кроки:  
1) завантажити модуль;  
2) зайти в адміністративний центр та перейти в «Розширення» 
=> «Менеджер модулів»;  
3) натиснути на кнопку «Створити» на панелі інструментів та 
обрати необхідний модуль;  
4) налаштувати параметри модуля та натиснути «Зберегти».  
Модуль CMS Joomla складається мінімально з двох файлів: 
mod_назвамодуля.xml та mod_назвамодуля.php, які за за мовчуванням 
розташовуються в папці «modules» на сервері.  
Файл mod_назвамодуля.xml – багатофункціональний файл, який 
містить загальні відомості про модуль – назву, опис, авторство, ве р-
сію, відомості для інсталювання/деінсталювання модуля – список 
файлів та  шляхи їх розміщення , список параметрів для конфігурації 
модуля.  
Файл mod_назвамодуля.php містить програмний код модуля.  
 
7.3 Завдання на лабораторну роботу  
 
7.3.1  Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
7.3.2  Ознайомитись з існуючими модулями розширення функц і-
ональності для обраного фреймворку.  
7.3.3  Проаналізувати вимоги до функціональності, що визначені 
в оформленій документації на ПЗ.  
7.3.4  Визначити необхідні модулі розширення функціонально с-
ті. 
7.3.5  Застосувати обрані мо дулі для вебзастос унку.  
7.3.6  Оформити звіт з роботи.  
7.3.7  Відповісти на контрольні питання.  
 
7.4 Зміст звіту  
 
7.4.1  Тема та мета роботи.  
7.4.2  Тема, обрана для проєкт ування.  
7.4.3  Вимоги до функціональності.  
7.4.4  Опис використаних модулів.  
78 
 
7.4.5  Архітектур а вебзастос унку після використання модулів.  
7.4.6  Структура вебзастос унку після використання модулів.  
7.4.7  Висновки, що містять відповіді на контрольні запитання, а 
також відображають результати виконання роботи та їх критичний 
аналіз.  
 
7.5 Контрольні запит ання  
 
7.5.1  Що таке модуль?  
7.5.2  Які модулі включає стандартний набір модулів обрано го 
фреймворку ? 
7.5.3  З яких файлів складається модуль розширення функціон а-
льності?  
7.5.4 Як інсталювати модуль розширення функціональності в 
проєкт  при роботі із обран им фреймворком ? 
 
 
 
  
79 
 
8 ЛАБОРАТОРНА РОБОТА №  8  
ТЕСТУВАННЯ ТА АНАЛІЗ ЯКОСТІ 
ВЕБ ЗАСТОСУНКІВ  
 
8.1 Мета роботи  
 
Навчитися оцінювати  якість веб застосунків  на основі пров еден-
ня те стування.  
 
8.2 Короткі теоретичні відомості  
 
Тестування ПЗ (Software Testing) – це процес технічного досл і-
дження, який виконується на вимогу замовників, і призначений для 
виявлення інформації про якість продукту відносно контексту, в як о-
му він має використовуватись.  
Програмний дефект ( баг) – помилка, вада або дефект в пр о-
грамі або системі, що викликає в ній неправильний або неочікуваний 
результат або неочікувану поведінку. Термін зазвичай використов у-
ється стосовно помилок, котрі виявляються на стадії роботи програми, 
на відміну від помилок проєктування чи синтаксичних помилок. «Б а-
ги» локалізуються та виправляються у процесі тестування та доробки 
програми.  
Різні системи баг-трекінгу пропонують різні шляхи опису сер-
йозності  та пріоритету  баг репорту, незмінним залишається лише 
сенс, що вкладаєть ся в ці поняття .  
Серйозність (severity) – це атрибут, що характеризує вплив д е-
фекту на працездатність програми.  
Пріоритет (priority) – це атрибут, який вказує на черговість в и-
конання завдання або усунення дефекту. Можна сказати, що це і н-
струмент менеджера  з планування робіт. Чим вище пріоритет, тим 
швидше потрібно виправити дефект.  
Градація серйозності дефекту може бути наступною:  
– блокуюча (blocker). Блокуюча помилка, що приводить заст о-
сунок в неробочий стан, в результаті якого подальша робота з сист е-
мою  або її ключовими функціями стає неможлива. Вирішення пр о-
блеми необхідне для подальшого функціонування системи;  
 
80 
 
– критична (critical). Критична помилка, неправильно працює 
ключова бізнес логіка, діра в системі безпеки, проблема, яка призвела 
до тимчасовог о падіння сервера або приводить в неробочий стан деяку 
частину системи, без можливості вирішення проблеми, використов у-
ючи інші вхідні точки. Вирішення проблеми необхідно для подальшої 
роботи з ключовими функціями системи;  
– значна (major). Значна помилка, частина основної бізнес лог і-
ки працює некоректно. Помилка не критична або є можливість для 
роботи з тестованою функцією, використовуючи інші вхідні точки;  
– незначна (minor). Незначна помилка, що не порушує бізнес -
логіку частини програми, що тестується, оч евидна проблема корист у-
вацького  інтерфейсу;  
– тривіальна (trivial).  Тривіальна помилка, не стосується бізнес -
логіки за стосунку. Загалом, така помилка не надає ніякого впливу на 
загальну якість продукту. Зазвичай, малопомітна  у користувацьк ому 
інтерфейс і, наприклад проблема сторонніх бібліотек або сервісів . 
Градація пріоритету є наступною : 
– високий (high). Помилка повинна бути виправлена якомога 
швидше, тому що її наявність є критичною для проєкт у; 
– середній (medium). Помилка повинна бути виправлена, її ная-
вність не є критичною, але вимагає обов'язкового рішення;  
– низький (low). Помилка повинна бути виправлена, її наявність 
не є критичною, і не вимагає термінового рішення.  
Вид тестування сфокусований на конкретну мету тестування, 
яка може бути перевіркою  функції, виконуваної компонентом, або си-
стеми в цілому. Мета тестування може бути спрямована як на переві р-
ку елементів нефункціонального тестування (надійність, зручність 
використання), структури, архітектури компонентів або системи в ц і-
лому, так і на еле менти залежно від змін у системі (перевірка випра в-
лення конкретного дефекту (повторне тестування або перевірка нен а-
вмисних змін).  
Залежно від мети  сам процес тестування повинен бути організ о-
ваний відповідним чином. Отже, можна  визначити 4 види тестування 
ПЗ: 
– функціональне тестування;  
– нефункціональне тестування;  
– структурне тестування;  
– тестування змін.  
81 
 
Функціональне тестування – тестування ПЗ, головною метою 
якого є перевірка реалізованості функціональних вимог додатка, тобто 
здатність додатка в задан их критеріях вирішувати поставлені  завда н-
ня.  
Елементи функціонального тестування:  
– підготовка тестових даних виходячи з документації;  
– бізнес -вимоги, як частина функціонального тестування;  
– отримання результатів на основі специфікації;  
– проходження те ст-кейсів;  
– аналіз фактичних і очікуваних результатів.  
Переваги функціонального тестування:  
– в рамках тестування проходить безпосереднє використання 
системи;  
– тестування, як правило, проводиться в умовах близьких до р е-
альних.  
Недоліки функціонального те стування:  
– існує ймовірність пропустити деяку кількість помилок логіки 
ПЗ під час перевірки функціоналу програми.  
Нефункціональне тестування ПЗ  – в першу чергу перевірка на 
відповідність нефункціональним вимогам:  
– зручність (загалом  проводиться оцінка зр учності для корист у-
вачів) ; 
– масштабованість ; 
– продуктивність ( працездатність  програми при різних навант а-
женнях) ; 
– безпека ( захист даних, захист даних програми, стійкість від 
злам у); 
– сумісність (с умісність та можливість переносу програми для й  
під різн і оточення, платформи , тощо ); 
– надійність (п оведінка системи при різних непередбачених с и-
туаціях, здатність обробки нестандартних дій користувача) . 
У нефункціональному тестуванні можна виділити наступні типи 
тестувань : 
– тестування стабільності програми – виявлення відмов системи 
під час використання ; 
– юзабіліті тестування – дослідження зручності використання ; 
– тестування ефективності – перевірка необхідних обсягів кодів, 
та ресурсів необхідних програмі для виконання окре мої функції ; 
82 
 
– тестування ремонтопридатності – визначає, наскільки легко 
підтримувати працездатність системи ; 
– перевірка сумісності (portability testing) – тестування досту п-
ності перенесення окремого компонента або всієї програми ; 
– тестування «пра -витокі в» (baseline testing) – перевірка докум е-
нтації та специфікації, за якою будуть написані тест -кейси. До цього 
підвиду тестування можна віднести і тестування вимог ; 
– приймальне тестування – перевірка продукту на відповідність 
критеріям готовності ; 
– тестува ння документації – перевірка створеної в рамках тест у-
вання документації ; 
– тестування витривалості системи – тестування системи при 
високому навантаженні протягом тривалого періоду часу з метою в и-
вчення її поведінки ; 
– навантажувальне тестування  – як прави ло, проводиться з м е-
тою визначення поведінки під очікуваним рівнем навантаження ; 
– тестування продуктивності – перевірка швидкості роботи ПЗ 
або його окремих функцій ; 
– тестування сумісності – тестування в різних середовищах: 
апаратна частина , програмна ча стина, тощо ; 
– тестування безпеки – перевірка застосунку на  безпеч ність та 
захищен ість; 
– об'ємне тестування  – тестування з використанням баз даних 
певного розміру ; 
– стрес тестування – це тестування в обмежених умовах ; 
– тестування швидкості відновлення  – визначення швидкості в і-
дновлення системи ; 
– тестування локалізації, інтернаціоналізація – перевірка на ві д-
повідність мовним, культурним та релігійним нормам .  
Структурне тестування спрямоване на тестування структури с и-
стеми або компонента. Цей вид тестува ння, як правило, відносять до 
тестування «білого» і «чорного» ящиків, так як перевіряється, що ві д-
бувається всередині системи або програми.  
Методи структурного тестування:  
– рядкове покриття – перевірка застосування всіх операторів у 
програмі на використан ня (хоча б один раз);  
 
83 
 
– покриття шляху  – перевірка для виконання критеріїв охо п-
лення кожного логічного шляху через програму;  
– покриття рішення – перевіряє, чи має кожна умова розгал у-
ження для програми істинні (true)  або помилкові  (false)  значення;  
– покриття умови – перевірка стану покриття для умовних і не 
умовних гілок.  
Переваги структурного тестування:  
– можливість виявити і видалити «зайвий» код;  
– можливість виявлення потенційних помилок на ранній стадії;  
– забезпечує більш ретельне тестування ПЗ;  
– не вимагає високих витрат людино -годин.  
Недоліки структурного тестування:  
– вимагає знання коду та інструментів тестування.  
Тестування змін – проводиться для зрозуміння різниці та корд о-
нів між поняттями «регресійне тестування» та «повторне тестування».  
Регрес ійне тестування (regression testing) проводиться з метою 
перевірки працездатності існуючого функціоналу і відсутності ст о-
ронніх помилок після внесення поправок чи доповнень в систему.  
Повторне тестування (pretesting) – проводиться для підтве р-
дження ви правлення помилки і роботи даного функціоналу.  
Види тестування розрізняють за часом проведення:  
– альфа -тестування:  
– димове тестування (smoke testing);  
– тестування нової функції (new feature testing);  
– регресійне тестування;  
– приймальне тестування;  
– бета-тестування.  
Альфа -тестування (alpha testing) – це вид приймального тест у-
вання, яке зазвичай проводиться на пізній стадії розробки продукту і 
включає імітацію реального використання продукту штатними розр о-
бниками або командою тестувальників. Зазвичай ал ьфа-тестування 
полягає в систематичній перевірці всіх функцій програми з викори с-
танням технік тестування «білого ящика» і «чорного ящика».  
Бета -тестування (beta testing) – інтенсивне використання майже 
готової версії продукту з метою виявлення максимальног о числа п о-
милок у його роботі для їх подальшого усунення перед остаточним 
виходом (релізом) продукту на ринок, до масового споживача. Бета -
тестування являє собою реально працюючу версію програми з повним 
84 
 
функціоналом. Завдання бета -тестів – оцінити можливо сті і стабіл ь-
ність роботи програми з точки зору її майбутніх користувачів.  
У таблиці 8.1 наведено порівняння альфа - та бета -тестування.  
 
Таблиця 8.1 – Порівняння альфа - та бета -тестування  
Альфа -тестування  Бета -тестування  
Головна мета  
Підвищує якість продукту і з а-
безпечує готовність до бета -
тестування.   
 Підвищує якість продукту, інте г-
рує дані про клієнта в гото вий 
продукт та  забезпечує готовність 
до випуску.  
Час проведення  
Ближче до кінця процесу розро б-
ки, коли продукт знаходиться в 
майже повністю п рацездатному 
стані.  Безпосередньо перед запуском.  
Тривалість  тестування  
Зазвичай дуже до вго – протягом 
багатьох ітерацій (часто в 3-5 ра-
зів довше  бета-тестування ).  Зазвичай тільки кілька тижнів 
(іноді до декількох місяців) з н е-
великою кількістю основних  іте-
рацій.  
Перевіряє  
Майже виключно пере вірка  якос-
ті ПЗ.  Зазвичай включає в себе марк е-
тинг, підтримку, документацію, 
якість і інжиніринг (в основному, 
всю групу продуктів).  
Хто проводить  
Зазвичай виконується тестерами, 
розробниками. Фокусується на 
тестуванні, яке буде емулювати 
близько 80% клієнтів.   Випробувано в «реальному світі» 
з «реальними клієнтами» і звор о-
тний зв'язок може охоплювати 
кожен елемент продукту.  
Що підлягає виправленню  
Більшість відомих критичних 
проблем виправлені деякі функції  
можуть бути змінені або додані в 
результаті ранньої зворотного 
зв'язку.   Велика частина зібраного  зворо т-
ного зв'язку розглядається та/або 
застосовується в майбутніх верс і-
ях продукту. Виконуються тільки 
важливі/критичні зміни.  
85 
 
Отримані результати  
Відмінн е уявлення про те, як пр а-
цює продукт і чи відповідає він 
критеріям дизайну ( і чи «бета -
готовий» він).   Уявлення про те, що клієнт думає 
про продукт, і про те, що він м о-
же відчувати, коли купує його.  
Наступні кроки  
Проходження бета -тестування  Випуск продукту  
 
Якість ПЗ – характеристика ПЗ, ступінь відповідності ПЗ вимо-
гам. Частіше за все  використовують визначення ISO 9001, згідно з 
яким якість – це «ступінь відповідності наявних характеристик вим о-
гам».  
Фактори якості – це нефункціональні вимоги до ПЗ, що відн о-
сяться до, наприклад, надійності та продуктивності програм.  
Деякі з факторів якості:  
Зрозумілість . Призначення ПЗ повинно бути зрозумілим з самої 
програми та документації.  
Повнота . Всі необхідні частини програми повинні бути пре д-
ставлені та реа лізовані.  
Стислість . Відсутність  надлишкової інформації та такої , що д у-
блюється. Реалізація принципів DRY  – Don't repeat yourself . 
Можливість портування . Легкість в адаптації програми до і н-
ших умов: архітектури, платформи, операційної системи тощо.  
Узгодженість . Вся документація та код повинні виконуватися 
за єдиними угодами, використовувати єдині формати та позначення . 
Покриття тестуванням . 
Зручність використання . 
Надійність . 
Безпечність . 
Чек-лист – це документ, що описує, що має бути протестовано. 
При цьому чек -лист може бути абсолютно різного рівня деталізації. 
Наскільки детальним буде чек -лист залежить від вимог до звітності, 
рівня знання продукту співробітниками і складності продукту.  
Чек-лист  потрібен для:  
– нагадування  про необхідні тести ; 
– розподілу  завдань за рівнем кваліфікації ; 
– збереження звітності та результатів тестування . 
86 
 
Чек-лист включає у себе:  
– список перевірок (з необхідним ступенем деталізації) ; 
– статус перевірок:  
– збірка, на якій проводилося тестування ; 
– тестове оточення (якщо застосовується) ; 
– тестувальник ; 
– результат перевірки . 
Приклад складання чек -листу для проходження тестування н а-
ведено на рисунку 8.1.  
 
Рисунок 8.1 – Приклад складання чек -листу  
 
Приклад чек -листу після проходження тестування наведено у 
Додатку Д. 
 
8.3 Завдання на лабораторну роботу  
8.3.1 Ознайомитися з теоретичними відомостями, необхідними 
для виконання роботи.  
8.3.2 Розробити чек-листи для тестування верстки та функціон у-
вання  вебзастос унку . 
8.3.3 Провести тестування верстки . 
8.3.4 Проаналізувати реалізованість функціональних вимог до 
ПЗ. 
8.3.5 Провести тестування функціональності вебзастос унку . 
8.3.6 Провести тестування стабільності.  
8.3.7 Оформити звіт з роботи.  
8.3.8 Відповісти на контрольні питання.  
 
8.4 Зміст звіту  
8.4.1 Тема та мета роботи.  

87 
 
8.4.2 Тема, обрана для проєкт ування.  
8.4.4 Опис тестів, застосованих для аналізу якості вебзастос ун-
ку, чек-листи тестування  та результат и тестування.  
8.4.5 Висновки, що містять відповіді на контрольні запитання, а 
також відображають результат и виконання роботи та їх критичний 
аналіз.  
 
8.5 Контрольні запитання  
 
8.5.1  Що таке баг?  
8.5.1  Як визначити серйозність та пріоритет багу?  
8.5.2 Як можна класифікувати види тестування?  
8.5.3 Що таке альфа - та бета -тестування?  
8.5.4 Що таке статичне та динамічне тестування?  
8.5.5 Які розрізняють фактори якості ПЗ? 
8.5.6 Як відбувається тестування навантажувальної здатності?  
8.5.7 Яким чином може проводитися перевірка ергономічності?  
8.5.8 Чим відрізняється тестування  за принципом  «білого ящ и-
ка» від тестування «чорного ящика» ? 
8.5.9 Як складається та що обов’язково  має включа ти до себе 
чек-лист?  
 
 
 
 
  
88 
 
ЛІТЕРАТУРА  
 
 
1. Wiegers  K. Software Requirements . 3rd ed ition [Text] / K. 
Wiegers , J. Beatty.  – Redmond  : Microsoft Press , 2013. – 672 p.  
2. Wiegers K. More About Software Requirements: Thorny Issues 
and Practical Advice [Text] / K.  Wiegers . – Redmond  : Microsoft Press , 
2005. – 224 p.  
3. Starck  E. Agile Project Management QuickStart Guide: A Simpl i-
fied Beginners Guide To Agile Project Management  [Text] / E. Starck . – 
Albany  : ClydeBank Media LLC , 2017 . – 166 p.  
4. Rothman J. Create Your Successful Agile Project  [Text] / J.  
Rothman . – Raleigh  : The Pragmatic Programmers, 2017 . – 225 p.  
5. Anderson D.  Essential Kanban Condensed [Text] / D. Anderson , 
A. Carmichael . – Seattle  : Lean Kanban University Press, 2016 . – 92 p.  
6. Rumpe B.  Modeling with UML: Language, Concepts, Methods  
[Text] / B. Rumpe . – New York  : Springer International Publishing , 2016 . – 
228 p.  
7. Bank C. Web UI Design Patterns 2014. A Deeper Look At The 
Hottest Websites and Web Apps Today [Text] / C. Bank, W. Zuberi . – 
Gdansk  : UXPin, 2014 . – 195 p.  
8. Faranello S. Practical UX Design [Text] / S. Faranello . – Bir-
mingham  : Packt Publishing, 2016 . – 232 p.  
9. Gothelf J. Lean UX: Designing Great Products with Agile Teams  
[Text] / J. Gothelf , J. Seiden . – Sebastopol  : O'Reilly Media, 2017 . – 208 p.  
10. Kunjumohamed S. pring MVC: Designing Real -World Web A p-
plications  [Text] / S. Kunjumohamed, H. Sattari, A. Bretet, G. Warin. – 
Birmingham  : Packt Publishing, 2016 . – 962 p.  
11. Wilson K. Spring MVC: Designing Real -World Web Applic a-
tions  [Text] / K. Wilson . – British Columbia  : Leanpub, 2015 . – 251 p.  
12. Stauffer M. Laravel: Up and Running: A Framework for Building 
Modern PHP Apps  [Text] / M. Stauffer . – Sebastopol  : O'Rei lly Media, 
2016. – 795 p.  
89 
 
13. Bašić M. A Collection of Laravel Tutorials [Text] / M. Bašić . – 
British Columbia  : Leanpub, 201 7. – 208 p.  
14. Portwood C. Yii Project Blueprints  [Text] / C. Portwood . – Bir-
mingham  : Packt Publishing, 2014. – 320 p.  
15. Asadi A. WordPress For Beginners . 7th edition  [Text] / A. Asadi . 
–Bournemouth  : Imagine Publishing, 2016 . – 196 p.  
16. Sabin -Wilson L. WordPress All -in-One For Dummies . 2nd edi-
tion [Text] / L. Sabin -Wilson . – New York  : John Wiley & Sons, Inc., 
2013 . – 840 p.  
17. Burge S . Joomla! 3 Explained: Your Step -by-Step Guide . 2nd 
edition [Text] / S. Burge . – Boston  : Addison -Wesley Professional, 2014. – 
448 p.  
18. Chumley C. Mastering Drupal 8 [Text] / C. Chumley, W. Hurley . 
– Birmingham  : Packt Publishing, 2017. – 456 p.  
19. Zandstra M. PHP Objects, Patterns, and Practice . 5th edition  
[Text] / M. Zandstra . – New York  : Apress, 2016 . – 583 p.  
20. Agarwal B.  B. Software Engineering And Testing: An Introdu c-
tion [Text] / B. B. Agarwal , M. Gupta , S. P. Tayal . – Burlington  : Jones & 
Bartlett Pub lishers, 2009 . – 515 p.  
21. Watkins J.  Testing IT: An Off -the-Shelf Software Testing Pr o-
cess. 2nd edition  [Text] / J. Watkins , S. Mills . – Cambridge  : Cambridge 
University Press, 20 10. – 354 p.  
 
 
  
90 
 
ДОДАТОК А  
ПРИКЛАДИ ТЕМ  
 
№ Тема  Обов’язково до реалізації  
1.  Інтернет -магазин  фізич-
них товарів  – реєстрація та авторизація корист у-
вачів;  
– оформлення та опрацювання (а д-
міністратором) замовлення;  
– вибір та опрацювання (адміністр а-
тором)  виду доставки замовлення;  
– групування товарів за категоріями;  
– оновлення та поп овнення асорт и-
менту товарів (адміністративна п а-
нель сайту).  
2.  Інтернет -магазин цифр о-
вих товарів (послуг)  – реєстрація та авторизація корист у-
вачів;  
– оформлення та опрацювання (а д-
міністратором) замовлення;  
– збереження та опрацювання (а д-
міністратором) архіву попередніх 
замовлень для можливості повто р-
ного замовлення;  
– групування товарів за категоріями;  
– оновлення та поповнення асорт и-
менту товарів (адміністративна п а-
нель сайту).  
3.  Сервіс з продажу тран с-
портних квитків  – реєстрація та авторизація корист у-
вачів;  
– оформлення та опрацювання (а д-
міністратором) замовлення;  
– можливість покупки квитків з/до 
проміжних станцій/зупинок;  
– оновлення маршрутів та кориг у-
вання кількості вільних місць на 
маршрутах (адміністративна панель 
сайту).  
 
91 
 
4.  Планер (щоденник -
органайзер)  – внесення інформації про майбутні 
плани у календар та уточнення часу;  
– ведення розділу «Календар»;  
– окреме ведення розділу «Зустрічі»  
(час, місце, вид зустрічі, учасники, 
нотатки ); 
– ведення розділу «Контакти»;  
– нагадування (push -повідомлення) 
про важливі події.  
5.  Інформаційний портал , 
присвячений кіно  – реєстрація та авторизація корист у-
вачів;  
– онлайн -перегляд трейлерів філ ь-
мів або фільмів -цілком;  
– виставлення оцінок та комент у-
вання улюблених кінострічок;  
– опрацювання (ад міністратором) 
коментарів;  
– групування кінострічок за жанр а-
ми; 
– рекомендація нових кінострічок на 
основі переглянутих;  
– оновлення матеріалів порталу 
(адміністративна панель сайту).  
6.  Фітне с-трекер  – внесення інформації про фізичну 
активність;  
– розроблення програм тренувань;  
– надання матеріалів про тренува н-
ня (статті в Інтернеті, відео -уроки, 
тощо);  
– окреме ведення розділу «Щоде н-
ник харчування» та надання матер і-
алів про правильне харчування 
(статті в Інтернеті, відео -уроки, т о-
що); 
– нагадування  (push -повідомлення) 
про внесення нових даних.  
 
92 
 
7.  Сервіс для прослухов у-
вання музики  – реєстрація та авторизація корист у-
вачів;  
– онлайн -прослуховування музики;  
– виставлення оцінок улюблених 
музикантів/колективів або окремих 
альбомів;  
– групування аудіозаписів за кат е-
горіями (за виконавцями , альбом а-
ми, жанрами) ; 
– рекомендація нових аудіозаписів 
на основі оцінених;  
– оновлення матеріалів сайту  (адм і-
ністративна панель сайту).  
8.  Система  
колективного блогу  – реєстрація та авторизація корист у-
вачів;  
– перегляд та ознайомлення із пу б-
лікаціями користувачів ; 
– групування публікацій за ключ о-
вими словами (тегами) та/або за к а-
тегоріями;  
– виставлення оцінок та комент у-
вання публікацій ; 
– можливість створення голосувань 
(в форматі окремого виду публік а-
цій або я к частини публікацій);   
– опрацювання (адміністратором) 
коментарів;  
– рекомендація та виведення публ і-
кацій за рейтингом найбільш поп у-
лярних ; 
– адмініст ративна панель сайту . 
9.  Інтернет -аукціон  – реєстрація та авторизація корист у-
вачів  (користувач може бути або 
покупцем, або продавцем) ; 
– класичний аукціон (збільшення 
ставки від мінімальної ціни) з зад а-
ним кроком та таймером, для визн а-
93 
 
чення переможця;  
– можливість миттєвої покупки за 
встановленою продавцем ціною ; 
– групування товарів за  категоріями;  
– моніторинг ходу торгів та вдалих 
угод  (адміністративна панель са й-
ту). 
10.  Соціальний  
інтернет -сервіс для фот о-
графів  – реєстрація та авторизація корист у-
вачів;  
– публікація власних фотоматері а-
лів; 
– захист авторських прав (захист від 
копіювання фотоматеріалів) кори с-
тувачів;  
– перегляд та ознайомлення із роб о-
тами фотографів;  
– можливість створення власних 
колекцій з фотоматеріалів інших 
користувачів;  
– виставлення оцінок та комент у-
вання публікацій;  
– опрацювання (адміністратором) 
комент арів;  
– рекомендація та виведення фото г-
рафій за рейтингом найбільш поп у-
лярних;  
– адміністративна панель сайту.  
11.  Файлообмінник  – реєстрація та авторизація корист у-
вачів;  
– розміщення та редагування прав 
доступу до власних файлів на сайті;  
– можливість перегляду та ознайо м-
лення із файлами з відкритим до с-
тупом;  
– групування файлів за типом (ауд і-
озаписи, зображення, кіно, книги, 
тощо)  
94 
 
– коментування файлами з відкр и-
тим доступом;  
– можливість відправлення миттєв о-
го посилання на файл з режимом 
доступу: «за п осиланням»;  
– адміністративна панель сайту.  
12.  Сервіс бронювання готе-
льних ном е-
рів/хостелів/житла  – реєстрація та авторизація корист у-
вачів;  
– оформлення та опрацювання (а д-
міністратором) заявок на бронюва н-
ня; 
– сортування пропозицій за на й-
ближчим часом до бажаного часу 
заселення та/або виселення;  
– підбір пропозицій на основі дод а-
ткових критеріїв (статус готелю, 
включений сніданок, наявність ку х-
ні, тощо)  
– виставлення оцінок та комент у-
вання;  
– оновлення пропозицій для брон ю-
вання (адміністр ативна панель са й-
ту). 
 
  
95 
 
ДОДАТОК Б  
ПРИКЛАД КАРТИ ІСТОРІ Й 
 
На рисунку Б.1  наведено приклад представлення карти історій 
для проєкт у «Інтернет -магазин».  
 
 
Рисунок Б.1  – Представлення карти історій для проєкт у «Інте р-
нет-магазин».  
 
  

96 
 
ДОДАТОК В  
ПРИКЛАД ОПИСУ ПОТОКУ ПОДІЙ  
 
У якості прикладу наведено потоки події прецеденту «Замо в-
лення книги у бібліотеці».  
На початку у вигляді таблиці представимо етапи основного п о-
току, альтернативних потоків та потоків помилок. Приклад наведено у 
таблиці В.1.  
 
Таблиця В.1 – Етапи основного потоку, альтернативних та п о-
милкових потоків  
Основний потік  Альтернативні потоки  Потоки помилок  
1. Бібліотекар просить 
надати абонемент.  А.1 У читача немає 
читацького квитка.  Е.1 Читач не 
пам’ятає, що вже 
отримував абон е-
мент.  
2. Читач надає  абон е-
мент.  А.2 У читача є забо р-
гованості.   
3. Бібліотекар перев і-
ряє дані за абонеме н-
том. А.3 Читач не може н а-
дати повну інформ а-
цію про книгу.   
4. Бібліотекар запитує 
інформацію про кн и-
гу. А.4 Не вдалось знайти 
книгу.   
5. Читач надає інфо р-
мацію.  А.5 Немає вільного 
примірника книги.   
6. Бібліотекар знах о-
дить книгу у каталозі.  А.6 Читач відмовл я-
ється надавати особи с-
ту інформацію.   
7. Бібліотекар видає 
екзем лір книги чит а-
чеві.  А.7 Читач вже поп е-
редньо отримував аб о-
немент.   
8. Бібліотекар робить 
запис  в реєстрі.    
9. Бібліотекар вносить 
зміни до каталогу.    
97 
 
Далі наведено детальний опис етапів.  
Етапи основного потоку подій.  
1. Бібліотекар просить надати абонемент (читацький квиток) ч и-
тача.  
2. Читач надає абонемент.  
А.1 У читача немає читацького квитка.  
3. Бібліотекар перевіряє дані за абонементом.  
А.2 У читача є заборгованості.  
4. Бібліотекар запитує інформацію про книгу (назва та прізвище 
автора) у читача.  
5. Читач надає інформацію про книгу для пошуку.  
А.3 Читач не може надати повну інформацію про книгу.  
6. Бібліотекар знаходить книгу у каталозі.  
А.4 Не вдалось знайти книгу.  
А.5 Немає вільного примірника книги.  
7. Бібліотекар видає екземпляр книги читачеві.  
8. Бібліотекар робить запис в реєстрі про: дату видачі, номер 
абонементу, очікувану дату повернення.  
9. Бібліотекар вносить зміни до каталогу про наявність вільних 
екземплярів.  
10. Прецедент завершено.  
Етапи альтернативних потоків.  
А.1 У читача немає читацького квитка.  
1. Бібліотекар пропонує завести абонемент у бібліотеці  
2. Читач погоджуєтьс я та надає особисту інформацію.  
А.6 Читач відмовляється надавати особисту інформ а-
цію. 
3. Бібліотекар перевіряє чи немає читача із аналогічними 
даними.  
А.7 Читач вже попередньо отримував абонемент.  
4. Бібліотекар виписує абонемент.  
5. Бібліотекар вносить да ні нового читача до реєстру ч и-
тачів бібліотеки.  
6. Потік повертається до кроку 4 основного потоку.  
А.2 У читача є заборгованості.  
1. Бібліотекар відмовляє читачу в обслуговуванні.  
2. Бібліотекар нагадує читачу про заборгованість.  
3. Потік повертається до к року 10 основного потоку.  
98 
 
А.3 Читач не може надати повну інформацію про книгу.  
1. Бібліотекар запитує часткову інформацію про книгу  
2. Бібліотекар виконує пошук за отриманою частковою 
інформацією про книгу.  
3. Потік повертається до кроку 10 основного потоку.  
А.4 Не вдалося знайти книгу.  
1. Бібліотекар повідомляє про відсутність книги.  
2. Бібліотекар пропонує здійснити пошук за частковою 
інформацією про книгу.  
3. Потік переходить до альтернативного потоку А.3.  
А.5 Немає вільного примірника книги.  
1. Біб ліотекар повідомляє, що вільного примірника немає  
2. Бібліотекар перевіряє реєстр та каталог.  
3. Бібліотекар повідомляє коли у найближчий час звіл ь-
ниться один із примірників.  
4. Потік повертається до кроку 10 основного потоку.  
А.6 Читач відмовляється надав ати особисту інформацію.  
1. Бібліотекар відмовляє в обслуговуванні читачу.  
2. Потік повертається до кроку 10 основного потоку.  
А.7 Читач вже попередньо отримував абонемент  
1. Бібліотекар повідомляє, що такий читач вже існує.  
Е.1 Читач не пам’ятає, що вже о тримував абон е-
мент.  
Етапи потоків помилок.  
Е.1 Читач не пам’ятає, що вже отримував абонемент.  
1. Бібліотекар пропонує читачу перевірити абонемент 
вдома.  
2. Потік повертається до кроку 10 основного потоку.  
 
  
99 
 
ДОДАТОК Д 
ПРИКЛАД СКЛАДАННЯ ЧЕ К-ЛИСТУ  
 
 
Рисунок Д.1 – Приклад чек -листу  

